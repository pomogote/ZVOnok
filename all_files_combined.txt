===== .gitignore =====
server/package-lock.json
client/package-lock.json
node_modules/
uploads/


===== client/.env =====
PORT=3001
REACT_APP_API_URL=http://localhost:3000


===== client/package.json =====
{
  "name": "client",
  "version": "1.0.0",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "dependencies": {
    "axios": "^1.6.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.6.0",
    "react-scripts": "5.0.1",
    "sass": "^1.89.0",
    "simple-peer": "^9.11.1",
    "socket.io-client": "^4.7.1"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}


===== client/public/index.html =====
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Chat Client</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>


===== client/src/App.js =====
import React, { useState, useEffect } from 'react';
import Login from './Login';
import ChatRoom from './ChatRoom';
import { fetchRooms } from './api';

export default function App() {
  const [token, setToken] = useState('');
  const [userId, setUserId] = useState('');
  const [username, setUsername] = useState('');
  const [rooms, setRooms] = useState([]);
  const [currentRoom, setCurrentRoom] = useState(null);

  useEffect(() => {
    if (token) {
      fetchRooms(token).then(setRooms);
    }
  }, [token]);

  if (!token) {
    return <Login onLogin={(tok, uid, uname) => {
      setToken(tok);
      setUserId(uid);
      setUsername(uname);
    }} />;
  }

  if (!currentRoom) {
    return (
      <div>
        <h2>–ß–∞—Ç—ã</h2>
        <ul>
          {rooms.map(room => (
            <li key={room.id}>
              <button onClick={() => setCurrentRoom(room)}>{room.name}</button>
            </li>
          ))}
        </ul>
        <button onClick={() => {
          setToken('');
          setUserId('');
          setUsername('');
        }}>–í—ã–π—Ç–∏</button>
      </div>
    );
  }

  return (
    <ChatRoom
      token={token}
      userId={userId}
      username={username}
      room={currentRoom}
      onLeave={() => setCurrentRoom(null)}
    />
  );
}


===== client/src/Call.js =====
import React, { useEffect, useRef, useState } from 'react';
import Peer from 'simple-peer';

export default function Call({ socket, token, userId, username, roomId, peerUser, onEnd }) {
  const [stream, setStream] = useState();
  const [peer, setPeer] = useState();
  const myVideo = useRef();
  const userVideo = useRef();

  useEffect(() => {
    navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then(currentStream => {
      setStream(currentStream);
      myVideo.current.srcObject = currentStream;

      if (!peerUser.incoming) {
        // –ò–Ω–∏—Ü–∏–∞—Ç–æ—Ä –∑–≤–æ–Ω–∫–∞
        const p = new Peer({ initiator: true, trickle: false, stream: currentStream });
        p.on('signal', data => {
          socket.emit('webrtc-signal', {
            roomId,
            toUserId: peerUser.id,
            fromUserId: userId,
            signal: data
          });
        });
        p.on('stream', userStream => {
          userVideo.current.srcObject = userStream;
        });
        setPeer(p);

        socket.emit('initiate-call', {
          targetUserId: peerUser.id,
          roomId,
          fromUserName: username
        });

        socket.on('webrtc-signal', ({ signal }) => {
          p.signal(signal);
        });
      } else {
        // –ü—Ä–∏–Ω–∏–º–∞—é—â–∏–π –∑–≤–æ–Ω–æ–∫
        const p = new Peer({ initiator: false, trickle: false, stream: currentStream });
        p.on('signal', data => {
          socket.emit('webrtc-signal', {
            roomId,
            toUserId: peerUser.id,
            fromUserId: userId,
            signal: data
          });
        });
        p.on('stream', userStream => {
          userVideo.current.srcObject = userStream;
        });
        setPeer(p);

        socket.on('webrtc-signal', ({ signal }) => {
          p.signal(signal);
        });

        socket.emit('accept-call', {
          fromUserId: userId,
          targetUserId: peerUser.id,
          roomId
        });
      }
    });

    return () => {
      if (peer) peer.destroy();
      if (stream) stream.getTracks().forEach(track => track.stop());
      socket.off('webrtc-signal');
    };
    // eslint-disable-next-line
  }, []);

  return (
    <div style={{border:'2px solid blue', padding:10, margin:10}}>
      <h3>–ó–≤–æ–Ω–æ–∫ —Å {peerUser.name}</h3>
      <div style={{display:'flex', gap:10}}>
        <video ref={myVideo} autoPlay muted style={{width:150}} />
        <video ref={userVideo} autoPlay style={{width:150}} />
      </div>
      <button onClick={onEnd}>–ó–∞–≤–µ—Ä—à–∏—Ç—å –∑–≤–æ–Ω–æ–∫</button>
    </div>
  );
}


===== client/src/ChatRoom.js =====
import React, { useEffect, useState, useRef } from 'react';
import io from 'socket.io-client';
import { fetchMessages } from './api';
import Call from './Call';
import axios from 'axios';

const SOCKET_URL = 'http://localhost:3000';

export default function ChatRoom({ token, userId, username, room, onLeave }) {
    const [messages, setMessages] = useState([]);
    const [text, setText] = useState('');
    const [callUser, setCallUser] = useState(null);
    const socketRef = useRef();

    useEffect(() => {

        //–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Ç–æ–∫–µ–Ω—É
        socketRef.current = io(SOCKET_URL, { auth: { token } });

        socketRef.current.emit('joinRoom', room.id);

        socketRef.current.on('newMessage', (msg) => {
            setMessages(prev => [...prev, msg]);
        });

        socketRef.current.on('incoming-call', ({ fromUserId, fromUserName }) => {
            if (window.confirm(`–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫ –æ—Ç ${fromUserName}. –ü—Ä–∏–Ω—è—Ç—å?`)) {
                setCallUser({ id: fromUserId, name: fromUserName, incoming: true });
            }
        });
        fetchMessages(room.id, token).then(setMessages);

        return () => socketRef.current.disconnect();

    }, [room.id, token]);

    const sendMessage = () => {
        if (!text.trim()) return;
        socketRef.current.emit('sendMessage', { text, roomId: room.id });
        setText('');
    };

    const startCall = (targetUserId, targetUserName) => {
        setCallUser({ id: targetUserId, name: targetUserName, incoming: false });
    };

    return (
        <div>
            <h2>–ö–æ–º–Ω–∞—Ç–∞: {room.name}</h2>
            <button onClick={onLeave}>–í—ã–π—Ç–∏ –∏–∑ –∫–æ–º–Ω–∞—Ç—ã</button>
            <div style={{ height: 300, overflowY: 'auto', border: '1px solid #ccc', margin: '10px 0' }}>
                {messages.map((msg, idx) => (
                    <div key={idx} style={{ marginBottom: '10px' }}>
                        <b>{msg.sender_name || 'User'}:</b>{' '}
                        {msg.is_voice_message ? (
                            <audio controls src={`http://localhost:3000${msg.file_url}`} />
                        ) : (
                            msg.text
                        )}
                        {msg.user_id !== userId && (

                            <button style={{ marginLeft: 10 }} onClick={() => startCall(msg.user_id, msg.user_name)}>
                                –ü–æ–∑–≤–æ–Ω–∏—Ç—å
                            </button>
                        )}
                    </div>
                ))}
            </div>
            <input
                value={text}
                onChange={e => setText(e.target.value)}
                onKeyDown={e => e.key === 'Enter' && sendMessage()}
                placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"
            />
            <button onClick={sendMessage}>–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
            <VoiceRecorder roomId={room.id} token={token} />

            {callUser && (
                <Call
                    socket={socketRef.current}
                    token={token}
                    userId={userId}
                    username={username}
                    roomId={room.id}
                    peerUser={callUser}
                    onEnd={() => setCallUser(null)}
                />
            )}
        </div>
    );
}

function VoiceRecorder({ roomId, token, onSend }) {

    const API_URL = process.env.REACT_APP_API_URL;

    const [recording, setRecording] = useState(false);
    const [mediaRecorder, setMediaRecorder] = useState(null);
    const [audioChunks, setAudioChunks] = useState([]);

    const startRecording = async () => {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const recorder = new window.MediaRecorder(stream);
        setMediaRecorder(recorder);
        setAudioChunks([]);

        recorder.ondataavailable = (e) => {
            setAudioChunks((prev) => [...prev, e.data]);
        };
        recorder.onstop = async () => {
            const blob = new Blob(audioChunks, { type: 'audio/webm' });
            const formData = new FormData();
            formData.append('voice', blob, `recording.webm`);
            formData.append('roomId', roomId.toString());

            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä
            const res = await axios.post(
                `${API_URL}/api/chat/voice`,
                formData,
                {
                    headers: {
                        Authorization: `Bearer ${token}`,
                        'Content-Type': 'multipart/form-data'
                    }
                }
            );
            // onSend –Ω—É–∂–µ–Ω —á—Ç–æ–±—ã —Å—Ä–∞–∑—É –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ, –µ—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –Ω–µ –ø—É—à–∏—Ç —á–µ—Ä–µ–∑ —Å–æ–∫–µ—Ç
            if (onSend) onSend(res.data);
        };

        recorder.start();
        setRecording(true);
    };

    const stopRecording = () => {
        mediaRecorder.stop();
        setRecording(false);
    };

    return (
        <div>
            {!recording ? (
                <button onClick={startRecording}>üé§ –ó–∞–ø–∏—Å–∞—Ç—å –≥–æ–ª–æ—Å</button>
            ) : (
                <button onClick={stopRecording}>‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
            )}
        </div>
    );
}


===== client/src/Login.js =====
import React, { useState } from 'react';
import { login } from './api';

export default function Login({ onLogin }) {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            const data = await login(email, password);
            onLogin(data.token, data.user.id, data.user.username);
        } catch (err) {
            setError('–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h2>–í—Ö–æ–¥</h2>
            <input
                placeholder="Email"
                value={email}
                onChange={e => setEmail(e.target.value)}
            />
            <input
                placeholder="–ü–∞—Ä–æ–ª—å"
                type="password"
                value={password}
                onChange={e => setPassword(e.target.value)}
            />
            <button type="submit">–í–æ–π—Ç–∏</button>
            {error && <div style={{ color: 'red' }}>{error}</div>}
        </form>
    );
}


===== client/src/api.js =====
import axios from 'axios';

const API_URL = 'http://localhost:3000';

export const login = async (email, password) => {
    const res = await axios.post(`${API_URL}/api/auth/login`, { email, password });
    return res.data;
};

export const fetchRooms = async (token) => {
    const res = await axios.get(`${API_URL}/api/rooms`, {
        headers: { Authorization: `Bearer ${token}` }
    });
    return res.data;
};

export const fetchMessages = async (roomId, token) => {
    const res = await axios.get(
        `${API_URL}/api/chat/rooms/${roomId}/messages`, // –î–æ–±–∞–≤–ª–µ–Ω —Å–µ–≥–º–µ–Ω—Ç /rooms/
        { headers: { Authorization: `Bearer ${token}` } }
    );
    return res.data;
};


===== client/src/index.js =====
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);


===== package-lock.json =====
{
  "name": "my-app",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "my-app",
      "version": "1.0.0",
      "devDependencies": {
        "concurrently": "^8.0.1"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.27.1.tgz",
      "integrity": "sha512-1x3D2xEk2fRo3PAhwQwu5UubzgiVWSXTBfWpVd2Mx2AzRqJuDJCsgaDVZ7HB5iGzDW1Hl1sWN2mFyKjmR9uAog==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/chalk/node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/cliui": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/cliui/-/cliui-8.0.1.tgz",
      "integrity": "sha512-BSeNnyus75C4//NQ9gQt1/csTXyo/8Sb+afLAkzAptFuMsod9HFokGNudZpi/oQV73hnVK+sR+5PVRMd+Dr7YQ==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "string-width": "^4.2.0",
        "strip-ansi": "^6.0.1",
        "wrap-ansi": "^7.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/concurrently": {
      "version": "8.2.2",
      "resolved": "https://registry.npmjs.org/concurrently/-/concurrently-8.2.2.tgz",
      "integrity": "sha512-1dP4gpXFhei8IOtlXRE/T/4H88ElHgTiUzh71YUmtjTEHMSRS2Z/fgOxHSxxusGHogsRfxNq1vyAwxSC+EVyDg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chalk": "^4.1.2",
        "date-fns": "^2.30.0",
        "lodash": "^4.17.21",
        "rxjs": "^7.8.1",
        "shell-quote": "^1.8.1",
        "spawn-command": "0.0.2",
        "supports-color": "^8.1.1",
        "tree-kill": "^1.2.2",
        "yargs": "^17.7.2"
      },
      "bin": {
        "conc": "dist/bin/concurrently.js",
        "concurrently": "dist/bin/concurrently.js"
      },
      "engines": {
        "node": "^14.13.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://github.com/open-cli-tools/concurrently?sponsor=1"
      }
    },
    "node_modules/date-fns": {
      "version": "2.30.0",
      "resolved": "https://registry.npmjs.org/date-fns/-/date-fns-2.30.0.tgz",
      "integrity": "sha512-fnULvOpxnC5/Vg3NCiWelDsLiUc9bRwAPs/+LfTLNvetFCtCTN+yQz15C/fs4AwX1R9K5GLtLfn8QW+dWisaAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.21.0"
      },
      "engines": {
        "node": ">=0.11"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/date-fns"
      }
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/get-caller-file": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
      "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": "6.* || 8.* || >= 10.*"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/require-directory": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
      "integrity": "sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/rxjs": {
      "version": "7.8.2",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.8.2.tgz",
      "integrity": "sha512-dhKf903U/PQZY6boNNtAGdWbG85WAbjT/1xYoZIC7FAY0yWapOBQVsVrDl58W86//e1VpMNBtRV4MaXfdMySFA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/shell-quote": {
      "version": "1.8.2",
      "resolved": "https://registry.npmjs.org/shell-quote/-/shell-quote-1.8.2.tgz",
      "integrity": "sha512-AzqKpGKjrj7EM6rKVQEPpB288oCfnrEIuyoT9cyF4nmGa7V8Zk6f7RRqYisX8X9m+Q7bd632aZW4ky7EhbQztA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/spawn-command": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/spawn-command/-/spawn-command-0.0.2.tgz",
      "integrity": "sha512-zC8zGoGkmc8J9ndvml8Xksr1Amk9qBujgbF0JAIWO7kXr43w0h/0GJNM/Vustixu+YE8N/MTrQ7N31FvHUACxQ==",
      "dev": true
    },
    "node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-color": {
      "version": "8.1.1",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz",
      "integrity": "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/supports-color?sponsor=1"
      }
    },
    "node_modules/tree-kill": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/tree-kill/-/tree-kill-1.2.2.tgz",
      "integrity": "sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "tree-kill": "cli.js"
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "dev": true,
      "license": "0BSD"
    },
    "node_modules/wrap-ansi": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/y18n": {
      "version": "5.0.8",
      "resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
      "integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/yargs": {
      "version": "17.7.2",
      "resolved": "https://registry.npmjs.org/yargs/-/yargs-17.7.2.tgz",
      "integrity": "sha512-7dSzzRQ++CKnNI/krKnYRV7JKKPUXMEh61soaHKg9mrWEhzFWhFnxPxGl+69cD1Ou63C13NUPCnmIcrvqCuM6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cliui": "^8.0.1",
        "escalade": "^3.1.1",
        "get-caller-file": "^2.0.5",
        "require-directory": "^2.1.1",
        "string-width": "^4.2.3",
        "y18n": "^5.0.5",
        "yargs-parser": "^21.1.1"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/yargs-parser": {
      "version": "21.1.1",
      "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-21.1.1.tgz",
      "integrity": "sha512-tVpsJW7DdjecAiFpbIB1e3qxIQsE6NoPc5/eTdrbbIC4h0LVsWhnoa3g+m2HclBIujHzsxZ4VJVA+GUuc2/LBw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    }
  }
}


===== package.json =====
{
  "name": "my-app",
  "version": "1.0.0",
  "scripts": {
    "start:client": "cd client && npm start",
    "start:server": "node index.js",
    "start": "concurrently \"npm run start:server\" \"npm run start:client\""
  },
  "devDependencies": {
    "concurrently": "^8.0.1"
  }
}


===== server/config/db.js =====
const { Pool } = require('pg');

const pool = new Pool({
  user: 'postgres',
  host: 'localhost',
  database: 'zvonokDB',
  password: '123',
  port: 5432, //??
});

module.exports = pool;


===== server/controllers/auth.controller.js =====
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const User = require('../models/user.model');

exports.register = async (req, res) => {
  try {
    const { name, email, password } = req.body;

    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ö–æ–¥—è—â–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    console.log(`[REGISTER] –ü–æ–ø—ã—Ç–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: ${email}`);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const existingUser = await User.findByEmail(email);
    if (existingUser) {
      console.warn(`[REGISTER] Email —É–∂–µ –∑–∞–Ω—è—Ç: ${email}`);
      return res.status(400).json({ error: "Email —É–∂–µ –∑–∞–Ω—è—Ç" });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await User.createUser(name, email, hashedPassword);

    //GOVNO
    const token = jwt.sign({ userId: user.id }, 'your_jwt_secret', { expiresIn: '10h' });

    console.log(`[REGISTER] –£—Å–ø–µ—à–Ω–æ: ID ${user.id}`);
    console.log('[LOGIN] Generated token:', token);

    res.status(201).json(user);
  } catch (error) {
    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–∫–∏ —Å –¥–µ—Ç–∞–ª—è–º–∏
    console.error('[REGISTER] –û—à–∏–±–∫–∞:', error.stack);
    res.status(500).json({ error: "Registration failed" });
  }
};

exports.login = async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findByEmail(email);
  if (!user || !(await bcrypt.compare(password, user.password_hash))) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  const token = jwt.sign({ userId: user.id }, 'your_jwt_secret', { expiresIn: '10h' }); // –í–†–ï–ú–Ø –°–ï–°–°–ò –ú–û–ñ–ù–û –ü–û–ú–ï–ù–Ø–¢–¨ –ï–° –ß–û
  res.json({
    token,
    user: { // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–∞–∑–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      id: user.id,
      name: user.name,
      email: user.email
    }
  });
};


===== server/controllers/chat.controller.js =====
const Message = require('../models/message.model');
const Room = require("../models/room.model");
const User = require("../models/user.model");
const upload = require("../middleware/upload");
const path = require('path');
const fs = require('fs');
let io;

exports.setIO = (ioInstance) => {
  io = ioInstance;
};


// –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è uploadToCloud - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ –ª–æ–∫–∞–ª—å–Ω–æ–º—É —Ñ–∞–π–ª—É
async function uploadToCloud(file) {
  // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∑–∫–∞ –≤ –æ–±–ª–∞–∫–æ
  // –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –¥–ª—è –¥–æ—Å—Ç—É–ø–∞
  return file.path;
}


exports.sendMessage = async (req, res) => {
  try {
    const { text, roomId } = req.body;

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!text?.trim()) return res.status(400).json({ error: "–ü—É—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ" });
    if (!roomId) return res.status(400).json({ error: "–ù–µ —É–∫–∞–∑–∞–Ω–∞ –∫–æ–º–Ω–∞—Ç–∞" });

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã
    const roomExists = await Room.findById(roomId);
    if (!roomExists) return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });

    // –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    const message = await Message.create(text, req.userId, roomId);

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–≤—Ç–æ—Ä–µ
    const user = await User.findById(req.userId);

    res.status(201).json({
      ...message,
      sender_name: user.name
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞:', error);
    res.status(500).json({ error: error.message });
  }
};

exports.sendVoiceMessage = async (req, res) => {
  try {
    const { roomId } = req.body;
    const voiceFile = req.file;

    if (!voiceFile) {
      return res.status(400).json({ error: "–§–∞–π–ª –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω" });
    }

    const room = await Room.findById(roomId);
    if (!room) {
      return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await User.findById(req.userId);
    if (!user) {
      return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
    }

    console.log('Received roomId:', req.body.roomId);
    console.log('File:', req.file);

    const fileUrl = `/uploads/voice/${voiceFile.filename}`;


    const isVoiceMessage = true;
    const message = await Message.create(
      "", // –û—á–∏—â–∞–µ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ
      req.userId,
      roomId,
      true, // –Ø–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è
      `/uploads/voice/${voiceFile.filename}`
    );

    // –ü–æ—Å–ª–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    const voiceMessage = {
      ...message, // –î–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
      user_name: user.name,
      file_url: `/uploads/voice/${voiceFile.filename}`,
      is_voice_message: true,
      created_at: new Date().toISOString()
    };

    console.log('–û—Ç–ø—Ä–∞–≤–∫–∞ —á–µ—Ä–µ–∑ —Å–æ–∫–µ—Ç:', voiceMessage); // –õ–æ–≥–∏—Ä—É–µ–º
    io.to(roomId).emit('newMessage', voiceMessage);

    res.status(201).json(message);
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞:", {
      message: error.message,
      stack: error.stack
    });
    res.status(500).json({
      error: "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏",
      details: "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ —Å–µ—Ä–≤–µ—Ä–∞"
    });
  }
};

exports.getMessages = async (req, res) => {
  try {
    const { roomId } = req.params;
    const messages = await Message.findByRoom(roomId);

    // –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø—É—Å—Ç—ã–µ, –ø—Ä–æ–≤–µ—Ä–∏–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã
    if (messages.length === 0) {
      const roomExists = await Room.findById(roomId);
      if (!roomExists) {
        return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
      }
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–≤—Ç–æ—Ä–µ
    const messagesWithAuthors = await Promise.all(
      messages.map(async msg => {
        const user = await User.findById(msg.sender_id);
        return {
          ...msg,
          user_name: user?.name || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π'
        };
      })
    );

    res.json(messages);
  } catch (error) {
    console.error('[ERROR] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π' });
  }
};


===== server/controllers/room.controller.js =====
const Room = require("../models/room.model");

exports.getAllRooms = async (req, res) => {
  try {
    const rooms = await Room.getAll();
    res.json(rooms);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch rooms" });
  }
};

exports.createRoom = async (req, res) => {
  try {
    const { name } = req.body;
    const room = await Room.create(name);
    res.status(201).json(room);
  } catch (error) {
    res.status(500).json({ error: "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã" });
  }
};

exports.getRoom = async (req, res) => {
  try {
    const { roomId } = req.params;
    const room = await Room.findById(roomId);
    if (!room) {
      return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
    }
    res.json(room);
  } catch (error) {
    res.status(500).json({ error: "–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã" });
  }
};


===== server/controllers/task.controller.js =====
const Task = require('../models/task.model');

exports.createTask = async (req, res) => {
  try {
    const { title, description, deadline } = req.body;
    const task = await Task.create(title, description, req.userId, deadline);
    res.status(201).json(task);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create task' });
  }
};

exports.getTasks = async (req, res) => {
  try {
    const tasks = await Task.findAllByUser(req.userId);
    res.json(tasks);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch tasks' });
  }
};

exports.updateTask = async (req, res) => {
  try {
    const { taskId } = req.params;
    const { status } = req.body;
    const task = await Task.updateStatus(taskId, status);
    res.json(task);
  } catch (error) {
    res.status(500).json({ error: 'Failed to update task' });
  }
};


===== server/index.js =====
const express = require('express');
const http = require('http');
const fs = require('fs');
const pool = require('./config/db');
const socketAuth = require('./middleware/socketAuth');
const Message = require('./models/message.model');
const path = require('path');
const chatController = require('./controllers/chat.controller');

pool.query('SELECT NOW()', (err) => {
  if (err) {
    console.error('PostgreSQL connection error:', err);
  } else {
    console.log('PostgreSQL connected successfully');
  }
});

const authRoutes = require('./routes/auth.routes');
const app = express();

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// CORS Configuration
const cors = require('cors');
app.use(cors({
  origin: 'http://localhost:3001', // –£–∫–∞–∑–∞—Ç—å —è–≤–Ω–æ –∫–ª–∏–µ–Ω—Ç—Å–∫–∏–π –ø–æ—Ä—Ç
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));

app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// Routes
app.use('/api/auth', require('./routes/auth.routes'));
app.use('/api/tasks', require('./routes/task.routes'));
app.use('/api/chat', require('./routes/chat.routes'));
app.use('/api/rooms', require('./routes/room.routes'));
app.use('/api/calls', require('./routes/call.routes'));

// Profile endpoint
app.get('/api/profile', require('./middleware/auth'), (req, res) => {
  res.json({ userId: req.userId });
});

//–ü–µ—Ä–µ—Ö–≤–∞—Ç –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π
process.on('uncaughtException', (error) => {
  console.error(`[CRASH] –ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: ${error.message}`);
  process.exit(1);
});

const server = http.createServer(app);

const io = require('socket.io')(server, {
  cors: {
    origin: "http://localhost:3001", // –°–æ–≤–ø–∞–¥–∞–µ—Ç —Å –∫–ª–∏–µ–Ω—Ç–æ–º
    methods: ["GET", "POST"],
    allowedHeaders: ["Authorization"],
    credentials: true
  },
  transports: ['websocket', 'polling']
});
io.use(socketAuth);
global._io = io;
chatController.setIO(io);

io.use((socket, next) => {
  const header = socket.handshake.headers.authorization;
  if (!token) return next(new Error('Authentication error'));


  const token = header.replace('Bearer ', '');
  jwt.verify(token, 'your_jwt_secret', (err, decoded) => {
    if (err) return next(new Error('Invalid token'));
    socket.userId = decoded.userId;
    next();
  });
});

// –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∫–æ–º–Ω–∞—Ç
const voiceRooms = new Map();

// –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
const activeConnections = new Map(); // roomId ‚Üí Set<peerId>
const peerConfigs = new Map(); // peerId ‚Üí { type: 'call' | 'conference', roomId }

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–æ–º–Ω–∞—Ç—É —á–∞—Ç–∞
  socket.on('joinRoom', (roomId) => {
    socket.join(roomId);
    console.log(`User joined chat room: ${roomId}`);
  });

  socket.on('chatMessage', async (data) => {
    console.log('Received chatMessage:', data);
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏ —ç–º–∏—Ç–∏–º
    const savedMessage = await saveMessageToDB(data.roomId, data.userId, data.message);
    io.to(data.roomId).emit('newMessage', savedMessage);
  });

  // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–æ–º–Ω–∞—Ç—É –¥–ª—è –≥–æ–ª–æ—Å–æ–≤–æ–π —Å–≤—è–∑–∏
  socket.on('joinVoiceRoom', (roomId) => {
    socket.join(roomId);

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–º–Ω–∞—Ç—É –µ—Å–ª–∏ –µ–µ –Ω–µ—Ç
    if (!voiceRooms.has(roomId)) {
      voiceRooms.set(roomId, new Set());
    }

    voiceRooms.get(roomId).add(socket.id);
    console.log(`User joined voice room: ${roomId}`);

    // –£–≤–µ–¥–æ–º–ª—è–µ–º –¥—Ä—É–≥–∏—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –æ –Ω–æ–≤–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
    socket.to(roomId).emit('new-peer', { peerId: socket.id });
  });

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤
  socket.on('webrtc-signal', (data) => {
    // –ü–µ—Ä–µ—Å—ã–ª–∞–µ–º —Å–∏–≥–Ω–∞–ª –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –ø–æ–ª—É—á–∞—Ç–µ–ª—é
    io.to(data.targetPeerId).emit('webrtc-signal', {
      senderId: socket.id,
      signal: data.signal,
      roomId: data.roomId
    });
  });

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è
  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);

    // –£–¥–∞–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –≤—Å–µ—Ö –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∫–æ–º–Ω–∞—Ç
    voiceRooms.forEach((participants, roomId) => {
      if (participants.has(socket.id)) {
        participants.delete(socket.id);
        socket.to(roomId).emit('peer-disconnected', { peerId: socket.id });
      }
    });
  });

  // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –∫–æ–º–Ω–∞—Ç—É
  socket.on('sendMessage', async (data) => {
    try {
      console.log('–ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —Å–æ–∫–µ—Ç:', data);

      const message = await Message.create(
        data.text,
        socket.userId,
        data.roomId
      );

      // –î–æ–±–∞–≤–ª—è–µ–º –∏–º—è –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
      const user = await User.findById(socket.userId);
      const messageWithSender = {
        ...message,
        sender_name: user.name
      };

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ–º –≤ –∫–æ–º–Ω–∞—Ç–µ, –≤–∫–ª—é—á–∞—è –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
      io.to(data.roomId).emit('newMessage', messageWithSender);
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
    }
  });

  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
  });

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–≤–æ–Ω–∫–∞ 1:1
  socket.on('initiate-call', ({ targetUserId, roomId }) => {
    socket.join(roomId);
    activeConnections.set(roomId, new Set([socket.id]));
    peerConfigs.set(socket.id, { type: 'call', roomId });
    socket.to(roomId).emit('incoming-call', { callerId: socket.id });
  });

  // –ü—Ä–∏–Ω—è—Ç–∏–µ –≤—Ö–æ–¥—è—â–µ–≥–æ –∑–≤–æ–Ω–∫–∞
  socket.on('accept-call', ({ roomId }) => {
    socket.join(roomId);
    const peers = activeConnections.get(roomId);
    peers.add(socket.id);
    io.to(roomId).emit('call-accepted', { participants: Array.from(peers) });
  });

  // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏
  socket.on('create-conference', (roomId) => {
    socket.join(roomId);
    activeConnections.set(roomId, new Set([socket.id]));
    peerConfigs.set(socket.id, { type: 'conference', roomId });
  });

  // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏
  socket.on('join-conference', (roomId) => {
    socket.join(roomId);
    const peers = activeConnections.get(roomId);
    peers.add(socket.id);
    io.to(roomId).emit('new-participant', { peerId: socket.id });
  });

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ WebRTC-—Å–∏–≥–Ω–∞–ª–æ–≤
  socket.on('webrtc-signal', ({ signal, targetPeerId, roomId }) => {
    socket.to(targetPeerId).emit('webrtc-signal', {
      senderId: socket.id,
      signal,
      roomId
    });
  });

  // –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —ç–∫—Ä–∞–Ω–∞
  socket.on('screen-share', ({ roomId, streamId }) => {
    const peers = activeConnections.get(roomId);
    peers.forEach(peerId => {
      if (peerId !== socket.id) {
        io.to(peerId).emit('screen-share-started', { streamId });
      }
    });
  });

  // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ
  socket.on('disconnect', () => {
    const config = peerConfigs.get(socket.id);
    if (config) {
      const roomId = config.roomId;
      const peers = activeConnections.get(roomId);
      peers.delete(socket.id);

      if (peers.size === 0) {
        activeConnections.delete(roomId);
      } else {
        io.to(roomId).emit('participant-left', { peerId: socket.id });
      }

      peerConfigs.delete(socket.id);
    }
    console.log('User disconnected:', socket.id);
  });

});

const PORT = 3000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

const uploadsDir = path.join(__dirname, 'uploads');
fs.mkdirSync(uploadsDir, { recursive: true });




===== server/middleware/auth.js =====
const jwt = require('jsonwebtoken');
const User = require('../models/user.model');

module.exports = (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');

  if (!token) return res.status(401).json({ error: 'Access denied' });

  try {
    const decoded = jwt.verify(token, 'your_jwt_secret');
    const user = User.findById(decoded.userId);

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    req.user = user;
    next();
    
  } catch (error) {
    res.status(400).json({ error: 'Invalid token' });
  }
};


===== server/middleware/logger.js =====
module.exports = (req, res, next) => {
  const start = Date.now();

  // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ö–æ–¥—è—â–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
  console.log(`[REQUEST] ${req.method} ${req.url}`);

  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`[RESPONSE] ${req.method} ${req.url} - Status: ${res.statusCode} (${duration}ms)`);
  });

  next();
};


===== server/middleware/socketAuth.js =====
const jwt = require('jsonwebtoken');

const socketAuth = (socket, next) => {
  try {
    const token = socket.handshake.auth.token;
    if (!token) {
      return next(new Error('Access denied: No token provided'));
    }

    const decoded = jwt.verify(token, 'your_jwt_secret');
    socket.userId = decoded.userId; // —Å–æ—Ö—Ä–∞–Ω—è–µ–º userId –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    next();
  } catch (error) {
    next(new Error('Invalid token'));
  }
};

module.exports = socketAuth;


===== server/middleware/upload.js =====
const multer = require("multer");
const path = require("path");
const fs = require("fs");

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –ø–∞–ø–∫–∏
const voiceDir = path.join(__dirname, "../uploads/voice");
fs.mkdirSync(voiceDir, { recursive: true });

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, voiceDir); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const cleanName = file.originalname.replace(/[^a-zA-Z0-9\.]/g, '_');
    cb(null, uniqueSuffix + '-' + cleanName);
  }
});

const upload = multer({
  storage: storage,
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('audio/')) {
      cb(null, true);
    } else {
      cb(new Error('–¢–æ–ª—å–∫–æ –∞—É–¥–∏–æ—Ñ–∞–π–ª—ã —Ä–∞–∑—Ä–µ—à–µ–Ω—ã'));
    }
  }
});

module.exports = upload;


===== server/models/message.model.js =====
const pool = require('../config/db');

class Message {
  static async create(text, senderId, roomId, isVoiceMessage = false, fileUrl = null) {

    if (isVoiceMessage) text = "";
    const { rows } = await pool.query(
      `INSERT INTO messages (text, sender_id, room_id, is_voice_message, file_url)
       VALUES ($1, $2, $3, $4, $5) RETURNING *`,
      [text, senderId, roomId, isVoiceMessage, fileUrl]
    );
    console.log('[DB] –°–æ–æ–±—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ:', rows[0]); // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    return rows[0];
  } catch(error) {
    console.error('[DB] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:', error);
    throw error;
  }

  static async findByRoom(roomId) {
    const { rows } = await pool.query(
      `SELECT 
      m.id,
      m.text,
      m.sender_id,
      m.room_id,
      m.is_voice_message,
      m.file_url,
      m.created_at,
      u.name as user_name
    FROM messages m
    LEFT JOIN users u ON m.sender_id = u.id
    WHERE m.room_id = $1
    ORDER BY m.created_at ASC`,
      [roomId]
    );
    return rows;
  }
}

module.exports = Message;


===== server/models/room.model.js =====
const pool = require("../config/db");

class Room {
  static async create(name, type = "chat") {
    const { rows } = await pool.query(
      "INSERT INTO rooms (name, type) VALUES ($1, $2) RETURNING *",
      [name, type]
    );
    return rows[0];
  }

  static async getAll() {
  const { rows } = await pool.query("SELECT * FROM rooms ORDER BY id ASC");
  return rows;
}

  static async findById(roomId) {
    const { rows } = await pool.query("SELECT * FROM rooms WHERE id = $1", [roomId]);
    return rows[0];
  }
}

module.exports = Room;


===== server/models/task.model.js =====
const pool = require('../config/db');
class Task {
  static async create(title, description, assigneeId, deadline) {
    const { rows } = await pool.query(
      `INSERT INTO tasks (title, description, status, assignee_id, deadline)
       VALUES ($1, $2, 'todo', $3, $4) RETURNING *`,
      [title, description, assigneeId, deadline]
    );
    return rows[0];
  }

  static async findAllByUser(userId) {
    const { rows } = await pool.query(
      `SELECT * FROM tasks WHERE assignee_id = $1`,
      [userId]
    );
    return rows;
  }

  static async updateStatus(taskId, newStatus) {
    const { rows } = await pool.query(
      `UPDATE tasks SET status = $1 WHERE id = $2 RETURNING *`,
      [newStatus, taskId]
    );
    return rows[0];
  }
}

module.exports = Task;


===== server/models/user.model.js =====
const pool = require('../config/db');
class User {
  static async findByEmail(email) {
    try {
      console.log(`[DB] –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email: ${email}`);
      const { rows } = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
      return rows[0];
    } catch (error) {
      console.error(`[DB] –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${error.message}`);
      throw error;
    }
  }

  static async findById(id) {
    try {
      const { rows } = await pool.query('SELECT * FROM users WHERE id = $1', [id]);
      return rows[0];
    } catch (error) {
      console.error(`[DB] –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${error.message}`);
      throw error;
    }
  }

  static async createUser(name, email, passwordHash) {
    const { rows } = await pool.query(
      'INSERT INTO users (name, email, password_hash) VALUES ($1, $2, $3) RETURNING *',
      [name, email, passwordHash]
    );
    return rows[0];
  }
}
module.exports = User;


===== server/node =====


===== server/package.json =====
{
  "name": "zvonok",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "express": "^5.1.0",
    "express-router": "^0.0.1",
    "jsonwebtoken": "^9.0.2",
    "mediasoup": "^3.15.7",
    "multer": "^1.4.5-lts.2",
    "path-to-regexp": "^8.2.0",
    "pg": "^8.15.6",
    "simple-peer": "^9.11.1",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1"
  }
}


===== server/routes/auth.routes.js =====
const express = require('express');
const router = express.Router();
const authController = require('../controllers/auth.controller');
const authMiddleware = require('../middleware/auth');

router.get('/profile', authMiddleware, async (req, res) => {
    try {
        // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ë–î
        const user = await User.findById(req.user.id);
        if (!user) {
            return res.status(404).json({ error: "User not found" });
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        res.json({
            user: {
                id: user.id,
                name: user.name,
                email: user.email
            }
        });

    } catch (error) {
        res.status(500).json({ error: "Server error" });
    }
});

router.post('/register', authController.register);
router.post('/login', authController.login);

module.exports = router;


===== server/routes/call.routes.js =====
const express = require('express');
const router = express.Router();
const webrtcService = require('../services/webrtc.service');
const authMiddleware = require('../middleware/auth');

router.post('/initiate', authMiddleware, (req, res) => {
  const roomId = webrtcService.generateRoomId();
  res.json({ roomId });
});

router.get('/ice-servers', (req, res) => {
  res.json({ servers: webrtcService.getICEServers() });
});

module.exports = router;


===== server/routes/chat.routes.js =====
const express = require('express');
const router = express.Router();
const chatController = require('../controllers/chat.controller');
const authMiddleware = require('../middleware/auth');
const upload = require("../middleware/upload");

router.post('/messages', authMiddleware, chatController.sendMessage);
router.get('/rooms/:roomId/messages', authMiddleware, chatController.getMessages);
router.post('/voice',
    authMiddleware,
    (req, res, next) => {
        console.log("Middleware: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏");
        next();
    },
    upload.single('voice'),
    (req, res, next) => {
        console.log("–§–∞–π–ª:", req.file); // –î–æ–±–∞–≤—å—Ç–µ –ª–æ–≥ —Ñ–∞–π–ª–∞
        req.body.roomId = req.body.roomId;
        next();
    },
    chatController.sendVoiceMessage
);

module.exports = router;


===== server/routes/room.routes.js =====
const express = require("express");
const router = express.Router();
const roomController = require("../controllers/room.controller");
const authMiddleware = require("../middleware/auth");

router.post("/", authMiddleware, roomController.createRoom);
router.get("/:roomId", authMiddleware, roomController.getRoom);
router.get("/", authMiddleware, roomController.getAllRooms);

module.exports = router;


===== server/routes/task.routes.js =====
const express = require('express');
const router = express.Router();
const taskController = require('../controllers/task.controller');
const authMiddleware = require('../middleware/auth');

router.post('/', authMiddleware, taskController.createTask);
router.get('/', authMiddleware, taskController.getTasks);
router.patch('/:taskId', authMiddleware, taskController.updateTask);

module.exports = router;


===== server/services/webrtc.service.js =====
class WebRTCService {
  constructor() {
    this.iceServers = [
      { urls: 'stun:stun.l.google.com:19302' },
      { 
        urls: 'turn:your-turn-server.com',
        username: 'user',
        credential: 'password'
      }
    ];
  }

  getICEServers() {
    return this.iceServers;
  }

  generateRoomId() {
    return Math.random().toString(36).substr(2, 9);
  }
}

module.exports = new WebRTCService();


===== server/sql/sql.sql =====
-- –°–æ–∑–¥–∞–µ–º —Ç–∏–ø –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–¥–∞—á–∏ (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ ENUM)
CREATE TYPE task_status AS ENUM ('todo', 'in_progress', 'done');

-- –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    --org_id INTEGER,  -- –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–∞–±–ª–∏—Ü–∞ organizations, –¥–æ–±–∞–≤—å—Ç–µ FOREIGN KEY
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –∫–æ–º–Ω–∞—Ç (—á–∞—Ç—ã/–∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏)
CREATE TABLE rooms (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255),
    type VARCHAR(20) CHECK (type IN ('chat', 'conference')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
CREATE TABLE messages (
    id SERIAL PRIMARY KEY,
    text TEXT,
    sender_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    room_id INTEGER REFERENCES rooms(id) ON DELETE CASCADE,
    is_voice_message BOOLEAN DEFAULT FALSE,
    file_url VARCHAR(512),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –∑–∞–¥–∞—á (–≤–∞—Ä–∏–∞–Ω—Ç —Å ENUM)
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    status task_status DEFAULT 'todo',
    assignee_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
    deadline TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞
CREATE INDEX idx_messages_room ON messages(room_id);
CREATE INDEX idx_tasks_assignee ON tasks(assignee_id);


