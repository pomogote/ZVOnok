===== .gitignore =====
server/package-lock.json
node_modules/
uploads/


===== client/index.html =====
<!DOCTYPE html>
<html>

<meta charset="UTF-8">

<head>
    <title>Messenger Demo</title>
    <style>
        body {
            font-family: Arial;
            max-width: 800px;
            margin: 0 auto;
        }

        #auth,
        #chat {
            margin: 20px;
            padding: 20px;
            border: 1px solid #ddd;
        }

        .message {
            margin: 10px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        #voiceBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px;
        }
    </style>
</head>

<body>
    <!-- –§–æ—Ä–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ -->
    <div id="auth">
        <input type="email" id="email" placeholder="Email">
        <input type="password" id="password" placeholder="Password">
        <button onclick="register()">Register</button>
        <button onclick="login()">Login</button>
    </div>

    <div id="currentRoom" style="margin:10px 0; font-weight:bold;"></div>

    <button id="logoutBtn">–í—ã–π—Ç–∏</button>
    <!-- –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å —á–∞—Ç–∞ -->
    <div id="chat" style="display: none;">
        <div id="rooms">
            <button onclick="createRoom()">Create Room</button>
            <div id="roomList"></div>
        </div>

        <div id="messages"></div>

        <input type="text" id="messageInput" placeholder="Message">
        <button onclick="sendMessage()">Send</button>
        <button id="voiceBtn" onmousedown="startRecording()" onmouseup="stopRecording()">
            üé§ Hold to record
        </button>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        let currentUser = null;
        let currentRoom = null;
        let socket = null;
        let mediaRecorder = null;
        let audioChunks = [];

        // API –º–µ—Ç–æ–¥—ã
        async function register() {
            const response = await fetch('http://localhost:3000/api/auth/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: 'Test User',
                    email: document.getElementById('email').value,
                    password: document.getElementById('password').value
                }),
                credentials: 'include'
            });
            const data = await response.json();
            console.log('Registered:', data);
        }

        socket.on('newMessage', (message) => {
            console.log('–ü–æ–ª—É—á–µ–Ω–æ –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:', message);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è
            if (message.is_voice_message) {
                addVoiceMessageToUI(message);
            } else {
                addTextMessageToUI(message);
            }
        });

        async function login() {
            const response = await fetch('http://localhost:3000/api/auth/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    email: document.getElementById('email').value,
                    password: document.getElementById('password').value
                })
            });

            const data = await response.json();
            if (data.token) {
                localStorage.setItem('token', data.token);

                // –ó–∞–ø—Ä–æ—Å –ø—Ä–æ—Ñ–∏–ª—è
                const profileRes = await fetch('http://localhost:3000/api/profile', {
                    headers: { Authorization: `Bearer ${data.token}` }
                });
                currentUser = await profileRes.json();

                initChat(data.token);
            } else {
                alert('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞: ' + (data.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        function addVoiceMessageToUI(message) {
            const messagesContainer = document.getElementById('messages');

            const messageElem = document.createElement('div');
            messageElem.className = 'message voice';

            // –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å –∏–º–µ–Ω–µ–º
            const header = document.createElement('div');
            header.innerHTML = `
    <span class="user-name">${message.user_name}</span>
    <span class="time">${new Date(message.created_at).toLocaleTimeString()}</span>
  `;

            // –ê—É–¥–∏–æ —ç–ª–µ–º–µ–Ω—Ç
            const audio = document.createElement('audio');
            audio.controls = true;
            audio.innerHTML = `
    <source src="http://localhost:3000${message.file_url}" type="audio/webm">
    –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∞—É–¥–∏–æ.
  `;

            messageElem.appendChild(header);
            messageElem.appendChild(audio);
            messagesContainer.appendChild(messageElem);

            // –ê–≤—Ç–æ–ø—Ä–æ–∫—Ä—É—Ç–∫–∞
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function addMessageToUI(message) {
            const messagesContainer = document.getElementById('messages');

            // –£–¥–∞–ª—è–µ–º —Ç–µ–∫—Å—Ç–æ–≤—É—é –º–µ—Ç–∫—É –¥–ª—è –≥–æ–ª–æ—Å–æ–≤—ã—Ö
            if (message.is_voice_message) {
                message.text = "";
            }

            const messageElem = document.createElement('div');
            messageElem.classList.add('message');

            // –ë–ª–æ–∫ –∞–≤—Ç–æ—Ä–∞
            const author = document.createElement('div');
            author.style.color = "#666";
            author.textContent = `${message.user_name}:`;
            messageElem.appendChild(author);

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö
            if (message.is_voice_message && message.file_url) {
                const audioWrapper = document.createElement('div');
                audioWrapper.style.marginTop = "5px";

                const audio = document.createElement('audio');
                audio.controls = true;
                audio.style.width = "250px";

                const source = document.createElement('source');
                source.src = `http://localhost:3000${message.file_url}`;
                source.type = 'audio/webm';

                audio.appendChild(source);
                audioWrapper.appendChild(audio);
                messageElem.appendChild(audioWrapper);
            }
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö
            else if (message.text) {
                const textElem = document.createElement('div');
                textElem.textContent = message.text;
                messageElem.appendChild(textElem);
            }

            messagesContainer.appendChild(messageElem);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function initChat(token) {
            document.getElementById('auth').style.display = 'none';
            document.getElementById('chat').style.display = 'block';

            socket = io('http://localhost:3000', {
                extraHeaders: {
                    Authorization: `Bearer ${token}`
                }
            });


            //–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
            socket.on('connect', () => {
                console.log('Socket connected:', socket.id);
            });

            // socket.on('newMessage', (msg) => {
            //     console.log('New message received:', msg);
            //     addMessageToUI(msg);
            // });

            socket.on('newMessage', (message) => {
                addMessageToUI({
                    userId: message.sender_id,
                    userName: message.user_name,
                    text: message.text,
                    isVoiceMessage: message.is_voice_message,
                    fileUrl: message.file_url
                });
            });

            // –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π

            loadRooms();
        }

        async function createRoom() {
            await fetch('http://localhost:3000/api/rooms', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${localStorage.getItem('token')}`
                },
                body: JSON.stringify({ name: prompt('Room name:') })
            });
            loadRooms();
        }

        document.getElementById('logoutBtn').onclick = function () {
            localStorage.removeItem('token');
            location.reload(); // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—É, –≤–æ–∑–≤—Ä–∞—â–∞—è –Ω–∞ —Ñ–æ—Ä–º—É –ª–æ–≥–∏–Ω–∞
        };

        async function joinRoom(roomId, roomName) {
            currentRoom = roomId;
            document.getElementById('currentRoom').textContent = "–¢–µ–∫—É—â–∞—è –∫–æ–º–Ω–∞—Ç–∞: " + roomName;
            document.getElementById('messages').innerHTML = ""; // –û—á–∏—â–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
            socket.emit('joinRoom', roomId);

            try {
                const response = await fetch(`http://localhost:3000/api/chat/rooms/${roomId}/messages`, {
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const messages = await response.json();
                console.log('–ü–æ–ª—É—á–µ–Ω—ã —Å–æ–æ–±—â–µ–Ω–∏—è:', messages);
                messages.forEach(addMessageToUI);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π:', error);
            }
        }

        async function loadRooms() {
            document.getElementById('roomList').innerHTML = "";
            const response = await fetch('http://localhost:3000/api/rooms', {
                headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
            });
            const rooms = await response.json();
            rooms.forEach(room => {
                const btn = document.createElement('button');
                btn.textContent = room.name;
                btn.onclick = () => joinRoom(room.id, room.name);
                document.getElementById('roomList').appendChild(btn);
            });
        }

        function sendMessage() {
            if (!currentRoom) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–Ω–∞—Ç—É –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è');
                return;
            }

            const message = document.getElementById('messageInput').value.trim();
            if (!message) return;

            socket.emit('sendMessage', {
                text: message,
                roomId: currentRoom
            });

            document.getElementById('messageInput').value = '';
        }

        // –ì–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        async function startRecording() {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'audio/webm; codecs=opus' // –Ø–≤–Ω–æ–µ —É–∫–∞–∑–∞–Ω–∏–µ –∫–æ–¥–µ–∫–æ–≤
            });
            mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
            mediaRecorder.start();
        }

        async function stopRecording() {
            mediaRecorder.stop();
            mediaRecorder.onstop = async () => {
                try {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const formData = new FormData();
                    formData.append('voice', audioBlob, 'recording.webm');
                    formData.append('roomId', currentRoom);

                    const response = await fetch('http://localhost:3000/api/chat/voice', {
                        method: 'POST',
                        headers: {
                            Authorization: `Bearer ${localStorage.getItem('token')}`
                        },
                        body: formData
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏:', error);
                    alert('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è');
                } finally {
                    audioChunks = [];
                }
            };
        }



        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        if (localStorage.getItem('token')) {
            initChat(localStorage.getItem('token'));
        }
    </script>
</body>

</html>



===== server/config/db.js =====
const { Pool } = require('pg');

const pool = new Pool({
  user: 'postgres',
  host: 'localhost',
  database: 'zvonokDB',
  password: '123',
  port: 5432, //??
});

module.exports = pool;


===== server/controllers/auth.controller.js =====
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const User = require('../models/user.model');

exports.register = async (req, res) => {
  try {
    const { name, email, password } = req.body;

    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ö–æ–¥—è—â–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    console.log(`[REGISTER] –ü–æ–ø—ã—Ç–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: ${email}`);

     // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const existingUser = await User.findByEmail(email);
    if (existingUser) {
      console.warn(`[REGISTER] Email —É–∂–µ –∑–∞–Ω—è—Ç: ${email}`);
      return res.status(400).json({ error: "Email —É–∂–µ –∑–∞–Ω—è—Ç" });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await User.createUser(name, email, hashedPassword);
    console.log(`[REGISTER] –£—Å–ø–µ—à–Ω–æ: ID ${user.id}`);
    res.status(201).json(user);
    
  } catch (error) {
    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–∫–∏ —Å –¥–µ—Ç–∞–ª—è–º–∏
    console.error('[REGISTER] –û—à–∏–±–∫–∞:', error.stack);
    res.status(500).json({ error: "Registration failed" });
  }
};

exports.login = async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findByEmail(email);
  if (!user || !(await bcrypt.compare(password, user.password_hash))) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  const token = jwt.sign({ userId: user.id }, 'your_jwt_secret', { expiresIn: '10h' }); // –í–†–ï–ú–Ø –°–ï–°–°–ò –ú–û–ñ–ù–û –ü–û–ú–ï–ù–Ø–¢–¨ –ï–° –ß–û
  res.json({ token });
};


===== server/controllers/chat.controller.js =====
const Message = require('../models/message.model');
const Room = require("../models/room.model");
const User = require("../models/user.model");
const upload = require("../middleware/upload");
const path = require('path');
const fs = require('fs');
let io;

exports.setIO = (ioInstance) => {
  io = ioInstance;
};


// –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è uploadToCloud - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ –ª–æ–∫–∞–ª—å–Ω–æ–º—É —Ñ–∞–π–ª—É
async function uploadToCloud(file) {
  // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∑–∫–∞ –≤ –æ–±–ª–∞–∫–æ
  // –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –¥–ª—è –¥–æ—Å—Ç—É–ø–∞
  return file.path;
}


exports.sendMessage = async (req, res) => {
  try {
    const { text, roomId, isVoiceMessage, fileUrl } = req.body;

    //–ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã
    const room = await Room.findById(roomId);
    if (!room) {
      return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
    }

    const message = await Message.create(text, req.userId, roomId, isVoiceMessage, fileUrl);
    res.status(201).json(message);
  } catch (error) {
    res.status(500).json({ error: 'Failed to send message' });
  }
};

exports.sendVoiceMessage = async (req, res) => {
  try {
    const { roomId } = req.body;
    const voiceFile = req.file;

    if (!voiceFile) {
      return res.status(400).json({ error: "–§–∞–π–ª –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω" });
    }

    const room = await Room.findById(roomId);
    if (!room) {
      return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await User.findById(req.userId);
    if (!user) {
      return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
    }

    const fileUrl = `/uploads/voice/${voiceFile.filename}`;


    const isVoiceMessage = true;
    const message = await Message.create(
      "", // –û—á–∏—â–∞–µ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ
      req.userId,
      roomId,
      true, // –Ø–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è
      `/uploads/voice/${voiceFile.filename}`
    );

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ —Å–æ–∫–µ—Ç
    io.to(roomId).emit('newMessage', {
      ...message,
      user_name: user.name, // –î–æ–±–∞–≤–ª—è–µ–º –∏–º—è
      file_url: message.file_url, // –ü–æ–ª–Ω—ã–π URL
      is_voice_message: true // –Ø–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º —Ç–∏–ø
    });

    res.status(201).json(message);
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞:", {
      message: error.message,
      stack: error.stack
    });
    res.status(500).json({
      error: "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏",
      details: "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ —Å–µ—Ä–≤–µ—Ä–∞"
    });
  }
};

exports.getMessages = async (req, res) => {
  try {
    const { roomId } = req.params;
    const messages = await Message.findByRoom(roomId);

    // –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø—É—Å—Ç—ã–µ, –ø—Ä–æ–≤–µ—Ä–∏–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã
    if (messages.length === 0) {
      const roomExists = await Room.findById(roomId);
      if (!roomExists) {
        return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
      }
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–≤—Ç–æ—Ä–µ
    const messagesWithAuthors = await Promise.all(
      messages.map(async msg => {
        const user = await User.findById(msg.sender_id);
        return {
          ...msg,
          user_name: user?.name || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π'
        };
      })
    );

    res.json(messages);
  } catch (error) {
    console.error('[ERROR] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π' });
  }
};


===== server/controllers/room.controller.js =====
const Room = require("../models/room.model");

exports.getAllRooms = async (req, res) => {
  try {
    const rooms = await Room.getAll();
    res.json(rooms);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch rooms" });
  }
};

exports.createRoom = async (req, res) => {
  try {
    const { name } = req.body;
    const room = await Room.create(name);
    res.status(201).json(room);
  } catch (error) {
    res.status(500).json({ error: "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã" });
  }
};

exports.getRoom = async (req, res) => {
  try {
    const { roomId } = req.params;
    const room = await Room.findById(roomId);
    if (!room) {
      return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
    }
    res.json(room);
  } catch (error) {
    res.status(500).json({ error: "–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã" });
  }
};


===== server/controllers/task.controller.js =====
const Task = require('../models/task.model');

exports.createTask = async (req, res) => {
  try {
    const { title, description, deadline } = req.body;
    const task = await Task.create(title, description, req.userId, deadline);
    res.status(201).json(task);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create task' });
  }
};

exports.getTasks = async (req, res) => {
  try {
    const tasks = await Task.findAllByUser(req.userId);
    res.json(tasks);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch tasks' });
  }
};

exports.updateTask = async (req, res) => {
  try {
    const { taskId } = req.params;
    const { status } = req.body;
    const task = await Task.updateStatus(taskId, status);
    res.json(task);
  } catch (error) {
    res.status(500).json({ error: 'Failed to update task' });
  }
};


===== server/index.js =====
const express = require('express');
const http = require('http');
const fs = require('fs');
const pool = require('./config/db');
const socketAuth = require('./middleware/socketAuth');
const Message = require('./models/message.model');
const path = require('path');
const chatController = require('./controllers/chat.controller');

pool.query('SELECT NOW()', (err) => {
  if (err) {
    console.error('PostgreSQL connection error:', err);
  } else {
    console.log('PostgreSQL connected successfully');
  }
});

const authRoutes = require('./routes/auth.routes');
const app = express();

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// CORS Configuration
const cors = require('cors');
app.use(cors({
  origin: '*', //http://localhost:8080
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));

app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// Routes
app.use('/api/auth', require('./routes/auth.routes'));
app.use('/api/tasks', require('./routes/task.routes'));
app.use('/api/chat', require('./routes/chat.routes'));
app.use('/api/rooms', require('./routes/room.routes'));
app.use('/api/calls', require('./routes/call.routes'));

// Profile endpoint
app.get('/api/profile', require('./middleware/auth'), (req, res) => {
  res.json({ userId: req.userId });
});

//–ü–µ—Ä–µ—Ö–≤–∞—Ç –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π
process.on('uncaughtException', (error) => {
  console.error(`[CRASH] –ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: ${error.message}`);
  process.exit(1);
});

const server = http.createServer(app);

const io = require('socket.io')(server, {
  cors: {
    origin: "http://localhost:8080",
    methods: ["GET", "POST"],
    credentials: true
  }
});
io.use(socketAuth);
global._io = io;
chatController.setIO(io);

// –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –∫–æ–º–Ω–∞—Ç
const voiceRooms = new Map();

// –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
const activeConnections = new Map(); // roomId ‚Üí Set<peerId>
const peerConfigs = new Map(); // peerId ‚Üí { type: 'call' | 'conference', roomId }

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–æ–º–Ω–∞—Ç—É —á–∞—Ç–∞
  socket.on('joinRoom', (roomId) => {
    socket.join(roomId);
    console.log(`User joined chat room: ${roomId}`);
  });

  socket.on('chatMessage', async (data) => {
    console.log('Received chatMessage:', data);
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏ —ç–º–∏—Ç–∏–º
    const savedMessage = await saveMessageToDB(data.roomId, data.userId, data.message);
    io.to(data.roomId).emit('newMessage', savedMessage);
  });

  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
  });

  // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–æ–º–Ω–∞—Ç—É –¥–ª—è –≥–æ–ª–æ—Å–æ–≤–æ–π —Å–≤—è–∑–∏
  socket.on('joinVoiceRoom', (roomId) => {
    socket.join(roomId);

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–º–Ω–∞—Ç—É –µ—Å–ª–∏ –µ–µ –Ω–µ—Ç
    if (!voiceRooms.has(roomId)) {
      voiceRooms.set(roomId, new Set());
    }

    voiceRooms.get(roomId).add(socket.id);
    console.log(`User joined voice room: ${roomId}`);

    // –£–≤–µ–¥–æ–º–ª—è–µ–º –¥—Ä—É–≥–∏—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –æ –Ω–æ–≤–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
    socket.to(roomId).emit('new-peer', { peerId: socket.id });
  });

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ WebRTC —Å–∏–≥–Ω–∞–ª–æ–≤
  socket.on('webrtc-signal', (data) => {
    // –ü–µ—Ä–µ—Å—ã–ª–∞–µ–º —Å–∏–≥–Ω–∞–ª –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –ø–æ–ª—É—á–∞—Ç–µ–ª—é
    io.to(data.targetPeerId).emit('webrtc-signal', {
      senderId: socket.id,
      signal: data.signal,
      roomId: data.roomId
    });
  });

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è
  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);

    // –£–¥–∞–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –≤—Å–µ—Ö –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∫–æ–º–Ω–∞—Ç
    voiceRooms.forEach((participants, roomId) => {
      if (participants.has(socket.id)) {
        participants.delete(socket.id);
        socket.to(roomId).emit('peer-disconnected', { peerId: socket.id });
      }
    });
  });

  // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –∫–æ–º–Ω–∞—Ç—É
  socket.on('sendMessage', async (data) => {
    try {
      const { text, roomId } = data;
      const message = await Message.create(text, socket.userId, roomId);
      io.to(roomId).emit('newMessage', message);
    } catch (error) {
      console.error('Error sending message:', error);
    }
  });

  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
  });

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–≤–æ–Ω–∫–∞ 1:1
  socket.on('initiate-call', ({ targetUserId, roomId }) => {
    socket.join(roomId);
    activeConnections.set(roomId, new Set([socket.id]));
    peerConfigs.set(socket.id, { type: 'call', roomId });
    socket.to(roomId).emit('incoming-call', { callerId: socket.id });
  });

  // –ü—Ä–∏–Ω—è—Ç–∏–µ –≤—Ö–æ–¥—è—â–µ–≥–æ –∑–≤–æ–Ω–∫–∞
  socket.on('accept-call', ({ roomId }) => {
    socket.join(roomId);
    const peers = activeConnections.get(roomId);
    peers.add(socket.id);
    io.to(roomId).emit('call-accepted', { participants: Array.from(peers) });
  });

  // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏
  socket.on('create-conference', (roomId) => {
    socket.join(roomId);
    activeConnections.set(roomId, new Set([socket.id]));
    peerConfigs.set(socket.id, { type: 'conference', roomId });
  });

  // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏
  socket.on('join-conference', (roomId) => {
    socket.join(roomId);
    const peers = activeConnections.get(roomId);
    peers.add(socket.id);
    io.to(roomId).emit('new-participant', { peerId: socket.id });
  });

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ WebRTC-—Å–∏–≥–Ω–∞–ª–æ–≤
  socket.on('webrtc-signal', ({ signal, targetPeerId, roomId }) => {
    socket.to(targetPeerId).emit('webrtc-signal', {
      senderId: socket.id,
      signal,
      roomId
    });
  });

  // –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —ç–∫—Ä–∞–Ω–∞
  socket.on('screen-share', ({ roomId, streamId }) => {
    const peers = activeConnections.get(roomId);
    peers.forEach(peerId => {
      if (peerId !== socket.id) {
        io.to(peerId).emit('screen-share-started', { streamId });
      }
    });
  });

  // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ
  socket.on('disconnect', () => {
    const config = peerConfigs.get(socket.id);
    if (config) {
      const roomId = config.roomId;
      const peers = activeConnections.get(roomId);
      peers.delete(socket.id);

      if (peers.size === 0) {
        activeConnections.delete(roomId);
      } else {
        io.to(roomId).emit('participant-left', { peerId: socket.id });
      }

      peerConfigs.delete(socket.id);
    }
    console.log('User disconnected:', socket.id);
  });

});

const PORT = 3000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

const uploadsDir = path.join(__dirname, 'uploads');
fs.mkdirSync(uploadsDir, { recursive: true });




===== server/middleware/auth.js =====
const jwt = require('jsonwebtoken');

module.exports = (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');
  if (!token) return res.status(401).json({ error: 'Access denied' });

  try {
    const decoded = jwt.verify(token, 'your_jwt_secret');
    req.userId = decoded.userId;
    next();
  } catch (error) {
    res.status(400).json({ error: 'Invalid token' });
  }
};


===== server/middleware/logger.js =====
module.exports = (req, res, next) => {
  const start = Date.now();

  // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ö–æ–¥—è—â–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
  console.log(`[REQUEST] ${req.method} ${req.url}`);

  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`[RESPONSE] ${req.method} ${req.url} - Status: ${res.statusCode} (${duration}ms)`);
  });

  next();
};


===== server/middleware/socketAuth.js =====
const jwt = require('jsonwebtoken');

const socketAuth = (socket, next) => {
  try {
    const token = socket.handshake.headers.authorization?.replace('Bearer ', '');
    if (!token) {
      return next(new Error('Access denied: No token provided'));
    }

    const decoded = jwt.verify(token, 'your_jwt_secret');
    socket.userId = decoded.userId; // —Å–æ—Ö—Ä–∞–Ω—è–µ–º userId –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    next();
  } catch (error) {
    next(new Error('Invalid token'));
  }
};

module.exports = socketAuth;


===== server/middleware/upload.js =====
const multer = require("multer");
const path = require("path");
const fs = require("fs");

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –ø–∞–ø–∫–∏
const voiceDir = path.join(__dirname, "../uploads/voice");
fs.mkdirSync(voiceDir, { recursive: true });

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, voiceDir); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const cleanName = file.originalname.replace(/[^a-zA-Z0-9\.]/g, '_');
    cb(null, uniqueSuffix + '-' + cleanName);
  }
});

const upload = multer({
  storage: storage,
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('audio/')) {
      cb(null, true);
    } else {
      cb(new Error('–¢–æ–ª—å–∫–æ –∞—É–¥–∏–æ—Ñ–∞–π–ª—ã —Ä–∞–∑—Ä–µ—à–µ–Ω—ã'));
    }
  }
});

module.exports = upload;


===== server/models/message.model.js =====
const pool = require('../config/db');

class Message {
  static async create(text, senderId, roomId, isVoiceMessage = false, fileUrl = null) {

    if (isVoiceMessage) text = "";
    const { rows } = await pool.query(
      `INSERT INTO messages (text, sender_id, room_id, is_voice_message, file_url)
       VALUES ($1, $2, $3, $4, $5) RETURNING *`,
      [text, senderId, roomId, isVoiceMessage, fileUrl]
    );
    console.log('[DB] –°–æ–æ–±—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ:', rows[0]); // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    return rows[0];
  } catch(error) {
    console.error('[DB] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:', error);
    throw error;
  }

  static async findByRoom(roomId) {
    const { rows } = await pool.query(
      `SELECT 
      m.id,
      m.text,
      m.sender_id,
      m.room_id,
      m.is_voice_message,
      m.file_url,
      m.created_at,
      u.name as user_name
    FROM messages m
    LEFT JOIN users u ON m.sender_id = u.id
    WHERE m.room_id = $1
    ORDER BY m.created_at ASC`,
      [roomId]
    );
    return rows;
  }
}

module.exports = Message;


===== server/models/room.model.js =====
const pool = require("../config/db");

class Room {
  static async create(name, type = "chat") {
    const { rows } = await pool.query(
      "INSERT INTO rooms (name, type) VALUES ($1, $2) RETURNING *",
      [name, type]
    );
    return rows[0];
  }

  static async getAll() {
  const { rows } = await pool.query("SELECT * FROM rooms ORDER BY id ASC");
  return rows;
}

  static async findById(roomId) {
    const { rows } = await pool.query("SELECT * FROM rooms WHERE id = $1", [roomId]);
    return rows[0];
  }
}

module.exports = Room;


===== server/models/task.model.js =====
const pool = require('../config/db');
class Task {
  static async create(title, description, assigneeId, deadline) {
    const { rows } = await pool.query(
      `INSERT INTO tasks (title, description, status, assignee_id, deadline)
       VALUES ($1, $2, 'todo', $3, $4) RETURNING *`,
      [title, description, assigneeId, deadline]
    );
    return rows[0];
  }

  static async findAllByUser(userId) {
    const { rows } = await pool.query(
      `SELECT * FROM tasks WHERE assignee_id = $1`,
      [userId]
    );
    return rows;
  }

  static async updateStatus(taskId, newStatus) {
    const { rows } = await pool.query(
      `UPDATE tasks SET status = $1 WHERE id = $2 RETURNING *`,
      [newStatus, taskId]
    );
    return rows[0];
  }
}

module.exports = Task;


===== server/models/user.model.js =====
const pool = require('../config/db');
class User {
  static async findByEmail(email) {
    try {
      console.log(`[DB] –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email: ${email}`);
      const { rows } = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
      return rows[0];
    } catch (error) {
      console.error(`[DB] –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${error.message}`);
      throw error;
    }
  }

  static async findById(id) {
    try {
      const { rows } = await pool.query('SELECT * FROM users WHERE id = $1', [id]);
      return rows[0];
    } catch (error) {
      console.error(`[DB] –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${error.message}`);
      throw error;
    }
  }

  static async createUser(name, email, passwordHash) {
    const { rows } = await pool.query(
      'INSERT INTO users (name, email, password_hash) VALUES ($1, $2, $3) RETURNING *',
      [name, email, passwordHash]
    );
    return rows[0];
  }
}
module.exports = User;


===== server/node =====


===== server/package.json =====
{
  "name": "zvonok",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "express": "^5.1.0",
    "express-router": "^0.0.1",
    "jsonwebtoken": "^9.0.2",
    "mediasoup": "^3.15.7",
    "multer": "^1.4.5-lts.2",
    "path-to-regexp": "^8.2.0",
    "pg": "^8.15.6",
    "simple-peer": "^9.11.1",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1"
  }
}


===== server/routes/auth.routes.js =====
const express = require('express');
const router = express.Router();
const authController = require('../controllers/auth.controller');

router.post('/register', authController.register);
router.post('/login', authController.login);

module.exports = router;


===== server/routes/call.routes.js =====
const express = require('express');
const router = express.Router();
const webrtcService = require('../services/webrtc.service');
const authMiddleware = require('../middleware/auth');

router.post('/initiate', authMiddleware, (req, res) => {
  const roomId = webrtcService.generateRoomId();
  res.json({ roomId });
});

router.get('/ice-servers', (req, res) => {
  res.json({ servers: webrtcService.getICEServers() });
});

module.exports = router;


===== server/routes/chat.routes.js =====
const express = require('express');
const router = express.Router();
const chatController = require('../controllers/chat.controller');
const authMiddleware = require('../middleware/auth');
const upload = require("../middleware/upload");

router.post('/messages', authMiddleware, chatController.sendMessage);
router.get('/rooms/:roomId/messages', authMiddleware, chatController.getMessages);
router.post('/voice',
    authMiddleware,
    (req, res, next) => {
        console.log("Middleware: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏");
        next();
    },
    upload.single('voice'),
    (req, res, next) => {
        console.log("–§–∞–π–ª:", req.file); // –î–æ–±–∞–≤—å—Ç–µ –ª–æ–≥ —Ñ–∞–π–ª–∞
        next();
    },
    chatController.sendVoiceMessage
);

module.exports = router;


===== server/routes/room.routes.js =====
const express = require("express");
const router = express.Router();
const roomController = require("../controllers/room.controller");
const authMiddleware = require("../middleware/auth");

router.post("/", authMiddleware, roomController.createRoom);
router.get("/:roomId", authMiddleware, roomController.getRoom);
router.get("/", authMiddleware, roomController.getAllRooms);

module.exports = router;


===== server/routes/task.routes.js =====
const express = require('express');
const router = express.Router();
const taskController = require('../controllers/task.controller');
const authMiddleware = require('../middleware/auth');

router.post('/', authMiddleware, taskController.createTask);
router.get('/', authMiddleware, taskController.getTasks);
router.patch('/:taskId', authMiddleware, taskController.updateTask);

module.exports = router;


===== server/services/webrtc.service.js =====
class WebRTCService {
  constructor() {
    this.iceServers = [
      { urls: 'stun:stun.l.google.com:19302' },
      { 
        urls: 'turn:your-turn-server.com',
        username: 'user',
        credential: 'password'
      }
    ];
  }

  getICEServers() {
    return this.iceServers;
  }

  generateRoomId() {
    return Math.random().toString(36).substr(2, 9);
  }
}

module.exports = new WebRTCService();


===== server/sql/sql.sql =====
-- –°–æ–∑–¥–∞–µ–º —Ç–∏–ø –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–¥–∞—á–∏ (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ ENUM)
CREATE TYPE task_status AS ENUM ('todo', 'in_progress', 'done');

-- –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    --org_id INTEGER,  -- –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–∞–±–ª–∏—Ü–∞ organizations, –¥–æ–±–∞–≤—å—Ç–µ FOREIGN KEY
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –∫–æ–º–Ω–∞—Ç (—á–∞—Ç—ã/–∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏)
CREATE TABLE rooms (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255),
    type VARCHAR(20) CHECK (type IN ('chat', 'conference')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
CREATE TABLE messages (
    id SERIAL PRIMARY KEY,
    text TEXT,
    sender_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    room_id INTEGER REFERENCES rooms(id) ON DELETE CASCADE,
    is_voice_message BOOLEAN DEFAULT FALSE,
    file_url VARCHAR(512),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –∑–∞–¥–∞—á (–≤–∞—Ä–∏–∞–Ω—Ç —Å ENUM)
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    status task_status DEFAULT 'todo',
    assignee_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
    deadline TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞
CREATE INDEX idx_messages_room ON messages(room_id);
CREATE INDEX idx_tasks_assignee ON tasks(assignee_id);


