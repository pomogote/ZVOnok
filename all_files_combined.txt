===== .gitignore =====
server/package-lock.json
client/package-lock.json
node_modules/
uploads/
package-lock.json


===== client/.env =====
PORT=3001
HOST=0.0.0.0
#REACT_APP_API_URL=http://localhost:3000
#REACT_APP_API_URL=http://188.232.170.223:3000
REACT_APP_API_URL=http://192.168.0.104:3000


===== client/package.json =====
{
  "name": "client",
  "version": "1.0.0",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "dependencies": {
    "axios": "^1.6.2",
    "buffer": "^6.0.3",
    "crypto-browserify": "^3.12.1",
    "process": "^0.11.10",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.6.0",
    "react-scripts": "5.0.1",
    "sass": "^1.89.0",
    "simple-peer": "^9.11.1",
    "socket.io-client": "^4.7.1",
    "stream-browserify": "^3.0.0",
    "window": "^4.2.7"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}


===== client/public/index.html =====
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <title>Chat Client</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>


===== client/src/App.js =====
import React, { useState, useEffect, useRef } from 'react';
import Login from './Login';
import Register from './Register';
import ChatRoom from './ChatRoom';
import TaskManager from './TaskManager';
import { fetchRooms, createRoom, deleteRoom } from './api';
import createSocket from './socket';

export default function App() {
  const [token, setToken] = useState('');
  const [userId, setUserId] = useState('');
  const [username, setUsername] = useState('');
  const [showRegister, setShowRegister] = useState(false);
  const [rooms, setRooms] = useState([]);
  const [currentRoom, setCurrentRoom] = useState(null);
  const [newRoomName, setNewRoomName] = useState(''); // –î–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤—ã—Ö –∫–æ–º–Ω–∞—Ç
  const [showTasks, setShowTasks] = useState(false);
  const socketRef = useRef(null);

  useEffect(() => {
    if (token) {
      socketRef.current = createSocket(token);
      socketRef.current.on('room-created', room => setRooms(prev => [...prev, room]));
      socketRef.current.on('room-deleted', ({ roomId }) =>
        setRooms(prev => prev.filter(r => r.id !== roomId))
      );
      fetchRooms(token).then(setRooms);
      return () => socketRef.current.disconnect();
    }
  }, [token]);

  const handleCreateRoom = async () => {
    if (!newRoomName.trim()) return;
    try {
      await createRoom(newRoomName, token);
      setNewRoomName('');
    } catch {
      alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É');
    }
  };

  const handleDeleteRoom = async roomId => {
    if (!window.confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –∫–æ–º–Ω–∞—Ç—É?')) return;
    try {
      await deleteRoom(roomId, token);
      setRooms(prev => prev.filter(r => r.id !== roomId));
      if (currentRoom?.id === roomId) setCurrentRoom(null);
    } catch {
      alert('–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∫–æ–º–Ω–∞—Ç—É');
    }
  };

  if (!token) {
    return (
      <div style={{ padding: 20, maxWidth: 400, margin: '0 auto' }}>
        {showRegister ? (
          <Register onRegistered={() => setShowRegister(false)} />
        ) : (
          <Login
            onLogin={(tok, uid, uname) => {
              setToken(tok);
              setUserId(uid);
              setUsername(uname);
            }}
          />
        )}
        <div style={{ marginTop: 10, textAlign: 'center' }}>
          <button
            onClick={() => setShowRegister(!showRegister)}
            style={{ background: 'none', border: 'none', color: '#06c', cursor: 'pointer' }}
          >
            {showRegister ? '–£–∂–µ –µ—Å—Ç—å –∞–∫–∫–∞—É–Ω—Ç? –í–æ–π—Ç–∏' : '–ù–µ—Ç –∞–∫–∫–∞—É–Ω—Ç–∞? –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è'}
          </button>
        </div>
      </div>
    );
  }

  // –†–µ–Ω–¥–µ—Ä —Ç–∞—Å–∫-–º–µ–Ω–µ–¥–∂–µ—Ä–∞
  if (showTasks) {
    return (
      <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
        <button
          onClick={() => setShowTasks(false)}
          style={{ marginBottom: '10px' }}
        >
          ‚Üê –ù–∞–∑–∞–¥ –∫ —á–∞—Ç–∞–º
        </button>
        <TaskManager token={token} />
      </div>
    );
  }

  // –°–ø–∏—Å–æ–∫ –∫–æ–º–Ω–∞—Ç
  if (!currentRoom) {
    return (
      <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
        <button
          onClick={() => setShowTasks(true)}
          style={{
            display: 'block',
            marginBottom: '20px',
            background: '#06c',
            color: 'white',
            padding: '8px 12px',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          –û—Ç–∫—Ä—ã—Ç—å —Ç–∞—Å–∫-–º–µ–Ω–µ–¥–∂–µ—Ä
        </button>
        <h2>–ß–∞—Ç—ã</h2>
        <div style={{ marginBottom: '20px' }}>
          <input
            value={newRoomName}
            onChange={e => setNewRoomName(e.target.value)}
            placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–æ–º–Ω–∞—Ç—ã"
            style={{ marginRight: '10px', padding: '5px' }}
          />
          <button onClick={handleCreateRoom}>–°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É</button>
        </div>
        <ul style={{ listStyle: 'none', padding: 0 }}>
          {rooms.map(room => (
            <li
              key={room.id}
              style={{
                margin: '10px 0',
                padding: '10px',
                border: '1px solid #ddd',
                borderRadius: '5px',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center'
              }}
            >
              <button
                onClick={() => setCurrentRoom(room)}
                style={{ flexGrow: 1, textAlign: 'left' }}
              >
                {room.name}
              </button>
              {room.creator_id === userId && (
                <button
                  onClick={() => handleDeleteRoom(room.id)}
                  style={{
                    background: 'red',
                    color: 'white',
                    border: 'none',
                    borderRadius: '50%',
                    width: '24px',
                    height: '24px',
                    cursor: 'pointer'
                  }}
                >
                  √ó
                </button>
              )}
            </li>
          ))}
        </ul>
        <button
          onClick={() => {
            setToken('');
            setUserId('');
            setUsername('');
          }}
          style={{ marginTop: '20px' }}
        >
          –í—ã–π—Ç–∏
        </button>
      </div>
    );
  }

  // –ö–æ–º–Ω–∞—Ç–∞ —á–∞—Ç–∞
  return (
    <ChatRoom
      token={token}
      userId={userId}
      username={username}
      room={currentRoom}
      onLeave={() => setCurrentRoom(null)}
    />
  );
}


===== client/src/Call.js =====
import React, { useEffect, useRef, useState } from 'react';
import Peer from 'simple-peer';

export default function Call({ socket, token, userId, username, roomId, peerUser, onEnd }) {
  const [stream, setStream] = useState(null);
  const [peer, setPeer] = useState(null);
  const myVideo = useRef(null);
  const userVideo = useRef(null);

  useEffect(() => {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –º–µ–¥–∏–∞—É—Å—Ç—Ä–æ–π—Å—Ç–≤
    if (!navigator.mediaDevices?.getUserMedia) {
      alert('–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –¥–æ—Å—Ç—É–ø –∫ –º–µ–¥–∏–∞—É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º');
      return;
    }

    let currentPeer = null;
    let currentStream = null;

    const initializeCall = async () => {
      try {
        // –ü–æ–ª—É—á–∞–µ–º –º–µ–¥–∏–∞–ø–æ—Ç–æ–∫
        currentStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });

        setStream(currentStream);
        myVideo.current.srcObject = currentStream;

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Peer —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        const isInitiator = !peerUser.incoming;
        currentPeer = new Peer({
          initiator: isInitiator,
          trickle: false,
          stream: currentStream
        });

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ WebRTC
        currentPeer.on('signal', data => {
          socket.emit('webrtc-signal', {
            roomId,
            toUserId: peerUser.id,
            fromUserId: userId,
            signal: data
          });
        });

        currentPeer.on('stream', userStream => {
          userVideo.current.srcObject = userStream;
        });

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
        const signalHandler = ({ signal }) => currentPeer.signal(signal);
        socket.on('webrtc-signal', signalHandler);

        // –ò–Ω–∏—Ü–∏–∏—Ä—É–µ–º/–ø—Ä–∏–Ω–∏–º–∞–µ–º –∑–≤–æ–Ω–æ–∫
        if (isInitiator) {
          socket.emit('initiate-call', {
            targetUserId: peerUser.id,
            roomId,
            fromUserName: username
          });
        } else {
          socket.emit('accept-call', {
            callId: peerUser.callId,
            fromUserId: userId,
            roomId
          });
        }

        setPeer(currentPeer);

      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–≤–æ–Ω–∫–∞:', error);
        handleMediaError(error);
      }
    };

    const handleMediaError = (error) => {
      let errorMessage = '–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º:';
      
      if (error.name === 'NotFoundError') {
        errorMessage += '\n- –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã';
      } else if (error.name === 'NotAllowedError') {
        errorMessage += '\n- –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω';
      } else {
        errorMessage += '\n- –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞';
      }

      alert(`${errorMessage}\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ:\n1. –†–∞–∑—Ä–µ—à–µ–Ω–∏—è –±—Ä–∞—É–∑–µ—Ä–∞\n2. –ü–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞\n3. HTTPS —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ`);
      onEnd();
    };

    initializeCall();

    // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ —Ä–∞–∑–º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
    return () => {
      if (currentPeer) {
        currentPeer.destroy();
        socket.off('webrtc-signal');
      }
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
    };
  }, []); // –ü—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π - –º–æ–Ω—Ç–∏—Ä—É–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑

  return (
    <div style={{ border: '2px solid blue', padding: 10, margin: 10 }}>
      <h3>–ó–≤–æ–Ω–æ–∫ —Å {peerUser.name}</h3>
      <div style={{ display: 'flex', gap: 10 }}>
        <video ref={myVideo} autoPlay muted playsInline style={{ width: 150 }} />
        <video ref={userVideo} autoPlay playsInline style={{ width: 150 }} />
      </div>
      <button onClick={onEnd}>–ó–∞–≤–µ—Ä—à–∏—Ç—å –∑–≤–æ–Ω–æ–∫</button>
    </div>
  );
}


===== client/src/ChatRoom.js =====
import React, { useEffect, useState, useRef } from 'react';
import { fetchMessages, updateMessage, deleteMessage } from './api';
import createSocket from './socket';
import Call from './Call';
import VoiceRecorder from './VoiceRecorder';
import ConferenceCall from './ConferenceCall';

const API_URL = process.env.REACT_APP_API_URL;

export default function ChatRoom({ token, userId, username, room, onLeave }) {
    const [messages, setMessages] = useState([]);
    const [text, setText] = useState('');
    const [callUser, setCallUser] = useState(null);
    const [conference, setConference] = useState(false);
    const socketRef = useRef();
    const [inConference, setInConference] = useState(false);
    const [confRunning, setConfRunning] = useState(false);

    useEffect(() => {
        // 1) –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ–∫–µ—Ç–∞
        socketRef.current = createSocket(token);
        // 2) –í—Ö–æ–¥–∏–º –≤ –∫–æ–º–Ω–∞—Ç—É
        socketRef.current.emit('joinRoom', room.id);

        // 3) –ü–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ —Å–æ–±—ã—Ç–∏—è
        socketRef.current.on('newMessage', msg => {
            setMessages(prev =>
                prev.some(m => m.id === msg.id) ? prev : [...prev, msg]
            );
        });
        socketRef.current.on('message-updated', ({ messageId, text }) => {
            setMessages(prev =>
                prev.map(m => (m.id === messageId ? { ...m, text } : m))
            );
        });
        socketRef.current.on('message-deleted', ({ messageId }) => {
            setMessages(prev => prev.filter(m => m.id !== messageId));
        });
        socketRef.current.on('incoming-call', ({ fromUserId, fromUserName }) => {
            if (window.confirm(`–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫ –æ—Ç ${fromUserName}. –ü—Ä–∏–Ω—è—Ç—å?`)) {
                setCallUser({ id: fromUserId, name: fromUserName, incoming: true });
            }
        });
        socketRef.current.on('new-conference-participant', () => {
            setConfRunning(true);
        });
        socketRef.current.on('conference-participant-left', () => {
            // –ö–æ–≥–¥–∞ –∫—Ç–æ-—Ç–æ –≤—ã—à–µ–ª, —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏ –Ω–µ—Ç, –µ—Å–ª–∏ –≤—ã –≤ –Ω–µ–π –Ω–µ –æ—Å—Ç–∞–ª–∏—Å—å
            // (–≤ –ø—Ä–æ—Å—Ç–µ–π—à–µ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏)
            setConfRunning(false);
        });
        // 4) –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏
        fetchMessages(room.id, token).then(setMessages);

        return () => {
            // —Å–Ω—è—Ç–∏–µ –≤—Å–µ—Ö –ø–æ–¥–ø–∏—Å–æ–∫ –∏ –¥–∏—Å–∫–æ–Ω–Ω–µ–∫—Ç
            socketRef.current.off('newMessage');
            socketRef.current.off('message-updated');
            socketRef.current.off('message-deleted');
            socketRef.current.off('incoming-call');
            socketRef.current.disconnect();
        };
    }, [room.id, token]);

    const sendMessage = () => {
        if (!text.trim()) return;
        socketRef.current.emit('sendMessage', { text, roomId: room.id });
        setText('');
    };

    const startCall = (targetUserId, targetUserName) => {
        setCallUser({ id: targetUserId, name: targetUserName, incoming: false });
    };


    const handleConferenceToggle = () => {
        if (!inConference) {
            // –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–µ–º—Å—è
            setInConference(true);
            setConfRunning(true);
            setConference(true);
            socketRef.current.emit('join-conference', { roomId: room.id });
        } else {
            // –≤—ã—Ö–æ–¥–∏–º
            setInConference(false);
            setConference(false);
            socketRef.current.emit('leave-conference', { roomId: room.id });
        }
    };

    // –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:
    const onEditClick = async (message) => {
        const newText = prompt('–ù–æ–≤—ã–π —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è:', message.text);
        if (newText != null && newText !== message.text) {
            try {
                await updateMessage(token, message.id, newText);
                // –ª–æ–∫–∞–ª—å–Ω–æ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º ‚Äî –∂–¥—ë–º socket 'message-updated'
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:', error.response?.data?.error || error.message);
            }
        }
    };

    const onDeleteClick = async (messageId) => {
        if (window.confirm('–£–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ?')) {
            try {
                await deleteMessage(token, messageId);
                // –ª–æ–∫–∞–ª—å–Ω–æ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º ‚Äî –∂–¥—ë–º socket 'message-deleted'
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è:', error.response?.data?.error || error.message);
            }
        }
    };

    return (
        <div>
            <h2>–ö–æ–º–Ω–∞—Ç–∞: {room.name}</h2>
            <button onClick={onLeave}>–í—ã–π—Ç–∏ –∏–∑ –∫–æ–º–Ω–∞—Ç—ã</button>
            <button
                onClick={handleConferenceToggle}
                style={{ marginLeft: 10 }}
            >
                {!inConference
                    ? (confRunning ? '–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏' : '–ù–∞—á–∞—Ç—å –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏—é')
                    : '–í—ã–π—Ç–∏ –∏–∑ –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏'}
            </button>

            <div style={{ height: 300, overflowY: 'auto', border: '1px solid #ccc', margin: '10px 0' }}>
                {messages.map(msg => {
                    // –∏–º—è –∞–≤—Ç–æ—Ä–∞: –æ—Ç–¥–∞—ë—Ç –ø—Ä–∏ live-—Å–æ–æ–±—â–µ–Ω–∏–∏ –∏–ª–∏ –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏
                    const author = msg.sender_name || msg.user_name || 'Unknown';
                    const authorId = msg.user_id || msg.sender_id;
                    const isMine = String(authorId) === String(userId);

                    return (
                        <div key={msg.id} style={{ position: 'relative', marginBottom: 10 }}>
                            {isMine && (
                                <button
                                    onClick={() => onDeleteClick(msg.id)}
                                    style={{
                                        position: 'absolute',
                                        right: 0,
                                        top: 0,
                                        background: '#ff4444',
                                        color: 'white',
                                        border: 'none',
                                        borderRadius: '4px',
                                        padding: '2px 6px',
                                        cursor: 'pointer'
                                    }}
                                >
                                    –£–¥–∞–ª–∏—Ç—å
                                </button>
                            )}

                            <b>{author}:</b>{' '}
                            {msg.is_voice_message
                                ? <audio controls src={`${API_URL}${msg.file_url}`} />
                                : msg.text
                            }

                            {/* –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å ‚Äî —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ */}
                            {isMine && !msg.is_voice_message && (
                                <button
                                    onClick={() => onEditClick(msg)}
                                    style={{
                                        marginLeft: 10,
                                        background: '#4CAF50',
                                        color: 'white',
                                        border: 'none',
                                        borderRadius: '4px',
                                        padding: '2px 6px',
                                        cursor: 'pointer'
                                    }}
                                >
                                    –†–µ–¥–∞–∫—Ç.
                                </button>
                            )}

                            {/* –ó–≤–æ–Ω–æ–∫ –¥—Ä—É–≥–∏–º */}
                            {!isMine && (
                                <button
                                    style={{ marginLeft: 10 }}
                                    onClick={() => setCallUser({ id: msg.user_id, name: author, incoming: false })}
                                >
                                    –ü–æ–∑–≤–æ–Ω–∏—Ç—å
                                </button>
                            )}
                        </div>
                    );
                })}
            </div>

            <input
                value={text}
                onChange={e => setText(e.target.value)}
                onKeyDown={e => e.key === 'Enter' && sendMessage()}
                placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ"
            />
            <button onClick={sendMessage}>–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>

            <VoiceRecorder
                roomId={room.id}
                token={token}
                onSend={msg => setMessages(prev => [...prev, msg])}
            />

            {callUser && (
                <Call
                    socket={socketRef.current}
                    token={token}
                    userId={userId}
                    username={username}
                    roomId={room.id}
                    peerUser={callUser}
                    onEnd={() => setCallUser(null)}
                />
            )}
            {conference && (
                <ConferenceCall
                    socket={socketRef.current}
                    token={token}
                    userId={userId}
                    username={username}
                    roomId={room.id}
                    onEnd={() => setConference(false)}
                />
            )}
        </div>
    );
}


===== client/src/ConferenceCall.js =====
import React, { useEffect, useRef, useState } from 'react';
import Peer from 'simple-peer';
import './css/ConferenceCall.css';

export default function ConferenceCall({ socket, userId, username = 'User', roomId, onEnd }) {
    const [stream, setStream] = useState(null);
    const [peers, setPeers] = useState([]);
    const [error, setError] = useState('');
    const peersRef = useRef([]);
    const myVideo = useRef(null);

    // Screen sharing states
    const [screenSharing, setScreenSharing] = useState(false);
    const [screenTrack, setScreenTrack] = useState(null);
    const [cameraTrack, setCameraTrack] = useState(null);
    const [screenSharingByPeer, setScreenSharingByPeer] = useState({});

    useEffect(() => {
        const init = async () => {
            try {
                const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true }).catch(() => null);
                const videoStream = await navigator.mediaDevices.getUserMedia({ video: true }).catch(() => null);
                const combined = new MediaStream([
                    ...(audioStream?.getTracks() || []),
                    ...(videoStream?.getTracks() || [])
                ]);
                setStream(combined);
                if (videoStream && videoStream.getVideoTracks().length) {
                    setCameraTrack(videoStream.getVideoTracks()[0]);
                }
                if (myVideo.current) myVideo.current.srcObject = combined;
                socket.emit('join-conference', { roomId, peerId: socket.id });
            } catch (err) {
                setError(`Initialization error: ${err.message}`);
            }
        };
        init();

        console.log("üîå Socket connected, id=", socket.id);

        socket.on('new-conference-participant', ({ peerId }) => {
            if (peerId === socket.id) return;
            if (peersRef.current.some(p => p.peerId === peerId)) return;
            const peer = new Peer({ initiator: true, trickle: false, stream });
            peer.on('signal', signal => {
                socket.emit('webrtc-signal', { target: peerId, senderId: socket.id, signal, roomId });
            });
            peer.on('error', e => console.error('Peer error:', e));
            peersRef.current.push({ peerId, peer });
            setPeers(prev => [...prev, { peerId, peer }]);
        });

        socket.on('webrtc-signal', ({ senderId, signal }) => {
            if (senderId === socket.id) return;
            const existing = peersRef.current.find(p => p.peerId === senderId);
            if (existing) {
                existing.peer.signal(signal);
            } else {
                const peer = new Peer({ initiator: false, trickle: false, stream });
                peer.on('signal', sig => {
                    socket.emit('webrtc-signal', { target: senderId, senderId: socket.id, signal: sig, roomId });
                });
                peer.on('error', e => console.error('Peer error:', e));
                peer.signal(signal);
                peersRef.current.push({ peerId: senderId, peer });
                setPeers(prev => [...prev, { peerId: senderId, peer }]);
            }
        });

        socket.on('conference-participant-left', ({ peerId }) => {
            peersRef.current = peersRef.current.filter(p => p.peerId !== peerId);
            setPeers(prev => prev.filter(p => p.peerId !== peerId));
            setScreenSharingByPeer(prev => {
                const next = { ...prev };
                delete next[peerId];
                return next;
            });
        });

        // Screen share
        socket.on('screen-share', ({ peerId }) => {
            console.log("üì° –ö–ª–∏–µ–Ω—Ç B –ø–æ–ª—É—á–∏–ª screen-share –æ—Ç", peerId);
            setScreenSharingByPeer(prev => ({ ...prev, [peerId]: true }));
        });
        socket.on('screen-share-stop', ({ peerId }) => {
            console.log("üì¥ –ö–ª–∏–µ–Ω—Ç B –ø–æ–ª—É—á–∏–ª screen-share-stop –æ—Ç", peerId);
            setScreenSharingByPeer(prev => {
                const next = { ...prev };
                delete next[peerId];
                return next;
            });
        });
        socket.on('screen-share-joined', ({ requesterId }) => {
            console.log("üëÄ –ö–ª–∏–µ–Ω—Ç A –ø–æ–ª—É—á–∏–ª screen-share-joined –æ—Ç", requesterId);
            const peerObj = peersRef.current.find(p => p.peerId === requesterId);
            if (peerObj && screenTrack && cameraTrack && !peerObj.peer.destroyed) {
                try {
                    peerObj.peer.replaceTrack(cameraTrack, screenTrack, stream);
                } catch (e) {
                    console.error('Failed replaceTrack on join:', e);
                }
            }
        });

        return () => {
            socket.off('new-conference-participant');
            socket.off('webrtc-signal');
            socket.off('conference-participant-left');
            socket.off('screen-share');
            socket.off('screen-share-stop');
            socket.off('screen-share-joined');
            stream?.getTracks().forEach(t => t.stop());
            peersRef.current.forEach(p => p.peer.destroy());
        };
    }, [socket, stream, screenTrack, cameraTrack]);

    const toggleMedia = type => {
        const tracks = stream?.getTracks().filter(t => t.kind === type);
        if (!tracks?.length) return;
        tracks.forEach(t => (t.enabled = !t.enabled));
        setStream(new MediaStream(stream.getTracks()));
    };

    const toggleScreenShare = async () => {
        if (!screenSharing) {
            try {
                const display = await navigator.mediaDevices.getDisplayMedia({ video: true });
                const [track] = display.getVideoTracks();
                setScreenTrack(track);
                setScreenSharing(true);
                peersRef.current.forEach(({ peer }) => {
                    if (!peer.destroyed) peer.replaceTrack(cameraTrack, track, stream);
                });
                socket.emit('screen-share', { roomId, peerId: socket.id });
            } catch (err) {
                console.error('Screen share error:', err);
            }
        } else {
            if (screenTrack) screenTrack.stop();
            setScreenSharing(false);
            peersRef.current.forEach(({ peer }) => {
                if (!peer.destroyed) peer.replaceTrack(screenTrack, cameraTrack, stream);
            });
            socket.emit('screen-share-stop', { roomId, peerId: socket.id });
        }
    };

    return (
        <div className="conference-container">
            <h3 className="conference-title">–ö–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏—è: {roomId}</h3>
            {error && <div className="error-message">{error}</div>}
            <div className="video-grid">
                {stream && stream.getVideoTracks().length > 0 ? (
                    <video ref={myVideo} autoPlay muted playsInline className="self-video" />
                ) : (
                    <div className="user-avatar"><span>{username[0].toUpperCase()}</span></div>
                )}
                {peers.map(({ peerId, peer }) => (
                    <div key={peerId} style={{ position: 'relative' }}>
                        <Video peer={peer} />
                        {screenSharingByPeer[peerId] && (
                            <button
                                className="screen-join-btn"
                                onClick={() => socket.emit('screen-share-join', { roomId, targetPeerId: peerId })}
                            >–°–º–æ—Ç—Ä–µ—Ç—å —ç–∫—Ä–∞–Ω</button>
                        )}
                    </div>
                ))}
            </div>
            <div className="controls">
                <button onClick={() => toggleMedia('audio')} className={`control-button ${stream?.getAudioTracks().length ? 'active' : ''}`}>üîä</button>
                <button onClick={() => toggleMedia('video')} className={`control-button ${stream?.getVideoTracks().length ? 'active' : ''}`}>üì∑</button>
                <button
                    onClick={toggleScreenShare}
                    className="control-button"
                    title={screenSharing ? '–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—é —ç–∫—Ä–∞–Ω–∞' : '–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —ç–∫—Ä–∞–Ω–∞'}
                >üì∫</button>
                <button onClick={onEnd} className="end-button">–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
            </div>
        </div>
    );
}

function Video({ peer }) {
    const ref = useRef();
    useEffect(() => {
        const handleStream = stream => {
            console.log('üì∫ got remote stream for peer', peer);
            ref.current.srcObject = stream;
        };
        peer.on('stream', handleStream);
        return () => peer.off('stream', handleStream);
    }, [peer]);
    return <video ref={ref} autoPlay playsInline className="peer-video" />;
}


===== client/src/Login.js =====
import React, { useState } from 'react';
import { login } from './api';

export default function Login({ onLogin }) {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            const data = await login(email, password);
            onLogin(data.token, data.user.id, data.user.username);
        } catch (err) {
            setError('–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h2>–í—Ö–æ–¥</h2>
            <input
                placeholder="Email"
                value={email}
                onChange={e => setEmail(e.target.value)}
            />
            <input
                placeholder="–ü–∞—Ä–æ–ª—å"
                type="password"
                value={password}
                onChange={e => setPassword(e.target.value)}
            />
            <button type="submit">–í–æ–π—Ç–∏</button>
            {error && <div style={{ color: 'red' }}>{error}</div>}
        </form>
    );
}


===== client/src/Register.js =====
// client/src/Register.js
import React, { useState } from 'react';
import { register } from './api';

export default function Register({ onRegistered }) {
  const [name, setName]       = useState('');
  const [email, setEmail]     = useState('');
  const [password, setPassword] = useState('');
  const [error, setError]     = useState('');

  const handleSubmit = async e => {
    e.preventDefault();
    try {
      await register(name, email, password);
      alert('–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞! –í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞.');
      onRegistered();  // –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ –ª–æ–≥–∏–Ω
    } catch (err) {
      console.error(err);
      setError(err.response?.data?.error || '–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <h2>–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è</h2>
      <input placeholder="–ò–º—è"    value={name}    onChange={e => setName(e.target.value)} />
      <input placeholder="Email"  value={email}   onChange={e => setEmail(e.target.value)} />
      <input placeholder="–ü–∞—Ä–æ–ª—å" type="password"
             value={password} onChange={e => setPassword(e.target.value)} />
      <button type="submit">–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è</button>
      {error && <div style={{ color: 'red' }}>{error}</div>}
    </form>
  );
}


===== client/src/TaskManager.js =====
import React, { useState, useEffect } from 'react';
import { fetchTasks, createTask, updateTask } from './api';

export default function TaskManager({ token, userId }) {
    const [tasks, setTasks] = useState([]);
    const [title, setTitle] = useState('');
    const [description, setDescription] = useState('');
    const [deadline, setDeadline] = useState('');
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);

    // –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç–≤–µ—Ç–∞ –æ—Ç API
    function normalizeList(response) {
        if (Array.isArray(response)) return response;
        if (response && Array.isArray(response.tasks)) return response.tasks;
        if (response && Array.isArray(response.data)) return response.data;
        return [];
    }

    // –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞ –∑–∞–¥–∞—á–∏
    function normalizeItem(response) {
        if (!response) return null;
        if (response.task) return response.task;
        if (response.data) return response.data;
        return response;
    }

    // –ó–∞–≥—Ä—É–∑–∫–∞ –∑–∞–¥–∞—á
    async function loadTasks() {
        setLoading(true);
        try {
            const result = await fetchTasks(token);
            const list = normalizeList(result);
            setTasks(list);
            setError(null);
        } catch (err) {
            console.error(err);
            setError('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∑–∞–¥–∞—á–∏');
        } finally {
            setLoading(false);
        }
    }

    useEffect(() => {
        if (token) loadTasks();
    }, [token]);

    // –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏
    async function handleCreate(e) {
        e.preventDefault();
        setError(null);
        try {
            const payload = { title, description, deadline, assignee_id: userId };
            const result = await createTask(payload, token);
            const newTask = normalizeItem(result);
            if (newTask) setTasks(prev => [newTask, ...prev]);
            setTitle('');
            setDescription('');
            setDeadline('');
        } catch (err) {
            console.error(err);
            setError('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏');
        }
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–¥–∞—á–∏
    async function handleStatus(task) {
        const next = { todo: 'in_progress', in_progress: 'done', done: 'todo' }[task.status];
        try {
            const result = await updateTask(task.id, next, token);
            const updated = normalizeItem(result);
            if (updated)
                setTasks(prev => prev.map(t => (t.id === updated.id ? updated : t)));
        } catch (err) {
            console.error(err);
            setError('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å');
        }
    }

    return (
        <div className="p-4 space-y-4 max-w-lg mx-auto">
            <button onClick={loadTasks} className="text-sm text-blue-600 hover:underline">
                –û–±–Ω–æ–≤–∏—Ç—å –∑–∞–¥–∞—á–∏
            </button>

            <form onSubmit={handleCreate} className="bg-white p-4 rounded shadow space-y-3">
                {error && <p className="text-red-600">{error}</p>}
                <input
                    className="w-full border px-3 py-2 rounded"
                    placeholder="–ó–∞–≥–æ–ª–æ–≤–æ–∫"
                    value={title}
                    onChange={e => setTitle(e.target.value)}
                    required
                />
                <textarea
                    className="w-full border px-3 py-2 rounded"
                    placeholder="–û–ø–∏—Å–∞–Ω–∏–µ"
                    value={description}
                    onChange={e => setDescription(e.target.value)}
                    required
                />
                <input
                    type="date"
                    className="w-full border px-3 py-2 rounded"
                    value={deadline}
                    onChange={e => setDeadline(e.target.value)}
                    required
                />
                <button type="submit" className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">
                    –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É
                </button>
            </form>

            {loading && <p>–ó–∞–≥—Ä—É–∑–∫–∞...</p>}
            {!loading && !tasks.length && <p>–ó–∞–¥–∞—á –Ω–µ—Ç.</p>}

            {!loading && tasks.length > 0 && (
                <div className="space-y-3">
                    {tasks.map((task, idx) =>
                        task ? (
                            <div
                                key={task.id || idx}
                                className="bg-white p-4 rounded shadow flex justify-between items-center"
                            >
                                <div>
                                    <h3 className="font-semibold">{task.title}</h3>
                                    <p className="text-sm">{task.description}</p>
                                    <p className="text-xs text-gray-500">
                                        –î–µ–¥–ª–∞–π–Ω: {new Date(task.deadline).toLocaleDateString()}
                                    </p>
                                    <p className="uppercase text-xs mt-1">–°—Ç–∞—Ç—É—Å: {task.status}</p>
                                    <p className="text-xs text-gray-600">
                                        –ù–∞–∑–Ω–∞—á–µ–Ω–æ: {task.assignee_id === userId ? '–í–∞–º' : task.assignee_id}
                                    </p>
                                </div>
                                <button
                                    onClick={() => handleStatus(task)}
                                    className="bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700"
                                >
                                    {task.status === 'done' ? '–í–æ–∑–≤—Ä–∞—Ç –≤ TODO' : '–°–ª–µ–¥. —Å—Ç–∞—Ç—É—Å'}
                                </button>
                            </div>
                        ) : null
                    )}
                </div>
            )}
        </div>
    );
}


===== client/src/VoiceRecorder.js =====
// src/VoiceRecorder.js
import React, { useState, useRef } from 'react';
import axios from 'axios';

export default function VoiceRecorder({ roomId, token, onSend }) {
  const [recording, setRecording] = useState(false);
  const [mediaRecorder, setMediaRecorder] = useState(null);
  const audioChunksRef = useRef([]);

  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const recorder = new window.MediaRecorder(stream);
      setMediaRecorder(recorder);
      audioChunksRef.current = [];

      recorder.ondataavailable = e => {
        if (e.data.size > 0) audioChunksRef.current.push(e.data);
      };
      recorder.onstop = async () => {
        if (!audioChunksRef.current.length) {
          alert("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø–∏—Å–∞—Ç—å –∞—É–¥–∏–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.");
          return;
        }
        const blob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
        const formData = new FormData();
        formData.append('voice', blob, `recording.webm`);
        formData.append('roomId', roomId);

        const res = await axios.post(
          `${process.env.REACT_APP_API_URL}/api/chat/voice`,
          formData,
          { headers: { Authorization: `Bearer ${token}` } }
        );
        if (res => onSend(res.data));
        //socketRef.current.emit('sendVoice', { roomId, file: formData });
      };

      recorder.start();
      setRecording(true);
    } catch (err) {
      console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É:', err);
      alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É.');
    }
  };


  const stopRecording = () => {
    if (mediaRecorder) {
      mediaRecorder.stop();
      setRecording(false);
    }
  };

  return (
    <div>
      {!recording
        ? <button onClick={startRecording}>üé§ –ó–∞–ø–∏—Å–∞—Ç—å –≥–æ–ª–æ—Å</button>
        : <button onClick={stopRecording}>‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
      }
    </div>
  );
}


===== client/src/api.js =====
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL;

export const login = async (email, password) => {
    const res = await axios.post(`${API_URL}/api/auth/login`, { email, password });
    return res.data;
};
// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
export const register = async (name, email, password) => {
    const res = await axios.post(`${API_URL}/api/auth/register`, {
        name, email, password
    });
    // —Å–µ—Ä–≤–µ—Ä –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –Ω–æ –±–µ–∑ —Ç–æ–∫–µ–Ω–∞,
    // —Ç–æ–∫–µ–Ω –ø—Ä–∏–¥—ë—Ç —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –ª–æ–≥–∏–Ω–∞
    return res.data;
};

export const fetchRooms = async (token) => {
    const res = await axios.get(`${API_URL}/api/rooms`, {
        headers: { Authorization: `Bearer ${token}` }
    });
    return res.data;
};

export const fetchMessages = async (roomId, token) => {
    const res = await axios.get(
        `${API_URL}/api/chat/rooms/${roomId}/messages`, // –î–æ–±–∞–≤–ª–µ–Ω —Å–µ–≥–º–µ–Ω—Ç /rooms/
        { headers: { Authorization: `Bearer ${token}` } }
    );
    return res.data;
};

export const createRoom = async (name, token) => {
    const res = await axios.post(`${API_URL}/api/rooms`, { name }, {
        headers: { Authorization: `Bearer ${token}` }
    });
    return res.data;
};

export const deleteRoom = async (roomId, token) => {
    await axios.delete(`${API_URL}/api/rooms/${roomId}`, {
        headers: { Authorization: `Bearer ${token}` }
    });
};

export const updateMessage = (token, messageId, text) => {
    return axios.put(`${API_URL}/api/messages/${messageId}`, { text }, {
        headers: {
            Authorization: `Bearer ${token}`
        }
    });
};

export const deleteMessage = (token, messageId) => {
    return axios.delete(`${API_URL}/api/messages/${messageId}`, {
        headers: { Authorization: `Bearer ${token}` }
    });
};

export const fetchTasks = (token) => {
    axios.get(`${API_URL}/api/tasks`, { headers: { Authorization: `Bearer ${token}` } })
        .then(res => res.data);
};

export const createTask = (task, token) => {
    axios.post(`${API_URL}/api/tasks`, task, { headers: { Authorization: `Bearer ${token}` } })
        .then(res => res.data);
};

export const updateTask = (taskId, status, token) => {
    axios.patch(`${API_URL}/api/tasks/${taskId}`, { status }, { headers: { Authorization: `Bearer ${token}` } })
        .then(res => res.data);
};


===== client/src/css/App.css =====
.video-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 10px;
  margin: 10px;
}

.video-participant {
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 5px;
}


===== client/src/css/ConferenceCall.css =====
.conference-container {
    border: 2px solid #4CAF50;
    border-radius: 8px;
    padding: 20px;
    margin: 10px;
    background: #f8fff8;
    max-width: 1000px;
    margin: 20px auto;
}

.conference-title {
    color: #2c7a2c;
    text-align: center;
    margin-bottom: 20px;
}

.video-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 10px;
    margin: 20px 0;
}

.self-video, .peer-video {
    width: 100%;
    border-radius: 8px;
    transform: scaleX(-1);
    background: #000;
    aspect-ratio: 16/9;
}

.user-avatar {
    width: 100%;
    aspect-ratio: 16/9;
    background: #4CAF50;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 48px;
    color: white;
    text-transform: uppercase;
}

.controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 20px;
}

.control-button {
    padding: 12px 24px;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    font-size: 18px;
    background: #e0e0e0;
    transition: all 0.3s;
}

.control-button.active {
    background: #4CAF50;
    color: white;
}

.end-button {
    padding: 12px 24px;
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    font-size: 18px;
    transition: opacity 0.3s;
}

.end-button:hover {
    opacity: 0.9;
}

.error-message {
    color: #dc3545;
    padding: 15px;
    margin: 15px 0;
    border: 1px solid #dc3545;
    border-radius: 8px;
    background: #fff0f0;
}

.retry-button {
    margin-top: 10px;
    padding: 8px 16px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    display: block;
}


===== client/src/index.js =====
import process from 'process';
globalThis.process = {
    env: { NODE_ENV: process.env.NODE_ENV },
    nextTick: (cb, ...args) => setTimeout(() => cb(...args), 0),
};
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);


===== client/src/socket.js =====
// src/socket.js
import { io } from 'socket.io-client';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000';

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —É–∂–µ —Å–∫–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–æ–∫–µ—Ç.
// –í tokenProvider() –º–æ–∂–Ω–æ –±—Ä–∞—Ç—å —Ç–æ–∫–µ–Ω –∏–∑ LocalStorage –∏–ª–∏ –∏–∑ –ª—é–±–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è.
// const socket = (token) => io(API_URL, {
//   auth: { token },
//   transports: ['websocket']
// });

// –û–±–Ω–æ–≤–∏–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Å–æ–∫–µ—Ç–∞
const socket = (token) => io(API_URL, {
  auth: { token },
  transports: ['websocket'],
  reconnection: true,
  reconnectionAttempts: 5,
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    // –î–æ–±–∞–≤—å—Ç–µ —Å–≤–æ–∏ TURN —Å–µ—Ä–≤–µ—Ä—ã –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
  ]
});

export default socket;


===== client/webpack.config.js =====
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  // –ü—É—Ç—å –∫ —Ç–æ—á–∫–µ –≤—Ö–æ–¥–∞
  entry: path.resolve(__dirname, 'src', 'index.js'),

  // –í—ã—Ö–æ–¥–Ω–æ–π –±–∞–Ω–¥–ª
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.[contenthash].js',
    publicPath: '/',
    clean: true, // –æ—á–∏—â–∞–µ—Ç –ø–∞–ø–∫—É dist –ø–µ—Ä–µ–¥ —Å–±–æ—Ä–∫–æ–π
  },

  // –†–µ–∂–∏–º: development –∏–ª–∏ production
  mode: process.env.NODE_ENV || 'development',

  resolve: {
    extensions: ['.js', '.jsx', '.json'],
    alias: {
      '@': path.resolve(__dirname, 'src'), // –¥–ª—è –∏–º–ø–æ—Ä—Ç–∞ —á–µ—Ä–µ–∑ @/
    },
  },

  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,       
        exclude: /node_modules/,    
        use: {
          loader: 'babel-loader',  
          options: {
            presets: [
              '@babel/preset-env',
              '@babel/preset-react'
            ]
          }
        }
      },
      {
        test: /\.css$/,
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: { importLoaders: 1 }
          },
          'postcss-loader' // –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ Tailwind/PostCSS
        ]
      },
      {
        test: /\.(png|jpe?g|gif|svg)$/i,
        type: 'asset/resource'
      }
    ]
  },

  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, 'public', 'index.html'),
      filename: 'index.html'
    })
  ],

  devServer: {
    static: {
      directory: path.resolve(__dirname, 'public'),
    },
    compress: true,
    port: 3000,
    historyApiFallback: true,
    hot: true,
    open: true
  },

  devtool: 'source-map'
};


===== server/config/db.js =====
const { Pool } = require('pg');

const pool = new Pool({
  user: 'postgres',
  host: 'localhost',
  database: 'zvonokDB',
  password: '123',
  port: 5432, //??
});

module.exports = pool;


===== server/controllers/auth.controller.js =====
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const User = require('../models/user.model');

exports.register = async (req, res) => {
  try {
    const { name, email, password } = req.body;

    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ö–æ–¥—è—â–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    console.log(`[REGISTER] –ü–æ–ø—ã—Ç–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: ${email}`);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const existingUser = await User.findByEmail(email);
    if (existingUser) {
      console.warn(`[REGISTER] Email —É–∂–µ –∑–∞–Ω—è—Ç: ${email}`);
      return res.status(400).json({ error: "Email —É–∂–µ –∑–∞–Ω—è—Ç" });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await User.createUser(name, email, hashedPassword);

    //GOVNO
    const token = jwt.sign({ userId: user.id }, 'your_jwt_secret', { expiresIn: '10h' });

    console.log(`[REGISTER] –£—Å–ø–µ—à–Ω–æ: ID ${user.id}`);
    console.log('[LOGIN] Generated token:', token);

    res.status(201).json(user);
  } catch (error) {
    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–∫–∏ —Å –¥–µ—Ç–∞–ª—è–º–∏
    console.error('[REGISTER] –û—à–∏–±–∫–∞:', error.stack);
    res.status(500).json({ error: "Registration failed" });
  }
};

exports.login = async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findByEmail(email);
  if (!user || !(await bcrypt.compare(password, user.password_hash))) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  const token = jwt.sign({ userId: user.id }, 'your_jwt_secret', { expiresIn: '10h' }); // –í–†–ï–ú–Ø –°–ï–°–°–ò –ú–û–ñ–ù–û –ü–û–ú–ï–ù–Ø–¢–¨ –ï–° –ß–û
  res.json({
    token,
    user: { // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–∞–∑–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      id: user.id,
      name: user.name,
      email: user.email
    }
  });
};


===== server/controllers/chat.controller.js =====
const Message = require('../models/message.model');
const Room = require("../models/room.model");
const User = require("../models/user.model");
const upload = require("../middleware/upload");
const path = require('path');
const fs = require('fs');
let io;

exports.setIO = (ioInstance) => {
  io = ioInstance;
};


// –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è uploadToCloud - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ –ª–æ–∫–∞–ª—å–Ω–æ–º—É —Ñ–∞–π–ª—É
async function uploadToCloud(file) {
  // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∑–∫–∞ –≤ –æ–±–ª–∞–∫–æ
  // –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –¥–ª—è –¥–æ—Å—Ç—É–ø–∞
  return file.path;
}


exports.sendMessage = async (req, res) => {
  try {
    const { text, roomId } = req.body;

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!text?.trim()) return res.status(400).json({ error: "–ü—É—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ" });
    if (!roomId) return res.status(400).json({ error: "–ù–µ —É–∫–∞–∑–∞–Ω–∞ –∫–æ–º–Ω–∞—Ç–∞" });

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã
    const roomExists = await Room.findById(roomId);
    if (!roomExists) return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });

    // –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    const message = await Message.create(text, req.userId, roomId);

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–≤—Ç–æ—Ä–µ
    const user = await User.findById(req.userId);

    res.status(201).json({
      ...message,
      sender_name: user.name
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞:', error);
    res.status(500).json({ error: error.message });
  }
};

exports.sendVoiceMessage = async (req, res) => {
  try {
    const roomId = req.body.roomId;
    const userId = req.userId;
    const user = await User.findById(userId);
    const fileUrl = `/uploads/voice/${req.file.filename}`;

    if (!roomId) {
      return res.status(400).json({ error: "–ù–µ —É–∫–∞–∑–∞–Ω–∞ –∫–æ–º–Ω–∞—Ç–∞" });
    }

    const voiceFile = req.file;
    if (!voiceFile) {
      return res.status(400).json({ error: "–§–∞–π–ª –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω" });
    }

    if (!req.userId) {
      return res.status(401).json({ error: "–¢–æ–∫–µ–Ω –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω" });
    }

    if (!user) {
      return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
    }

    const room = await Room.findById(roomId);
    if (!room) {
      return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
    }

    // –°–æ–∑–¥–∞—ë–º –∑–∞–ø–∏—Å—å —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –ë–î
    const message = await Message.create(
      "",          // text –ø—É—Å—Ç–æ–π
      userId,      // sender_id
      roomId,      // room_id
      true,        // is_voice_message
      fileUrl      // file_url
    );

    const payload = {
      ...message,
      user_id: userId,      // –¥–æ–±–∞–≤–ª—è–µ–º user_id –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞
      sender_name: user.name,
      is_voice_message: true,
      file_url: fileUrl
    };
    //global._io.to(String(roomId)).emit('newMessage', payload); //deepseek
    io.to(String(roomId)).emit('newMessage', payload);

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –∫–ª–∏–µ–Ω—Ç—É —Å –¥–∞–Ω–Ω—ã–º–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
    return res.status(201).json(payload);
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –≤ sendVoiceMessage:", error);
    res.status(500).json({
      error: "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è",
      details: "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ —Å–µ—Ä–≤–µ—Ä–∞"
    });
  }
};

exports.deleteMessage = async (req, res) => {

  try {
    const { messageId } = req.params;

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞
    const message = await Message.findById(messageId);
    if (!message) {
      return res.status(404).json({ error: "–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ" });
    }

    if (message.sender_id !== req.userId) {
      return res.status(403).json({ error: "–í—ã –º–æ–∂–µ—Ç–µ —É–¥–∞–ª—è—Ç—å —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏ —Å–æ–æ–±—â–µ–Ω–∏—è" });
    }

    await Message.delete(messageId);
    io.to(message.room_id).emit('message-deleted', { messageId });

    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: "–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è" });
  }

};

exports.getMessages = async (req, res) => {
  try {
    const { roomId } = req.params;
    const messages = await Message.findByRoom(roomId);

    // –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø—É—Å—Ç—ã–µ, –ø—Ä–æ–≤–µ—Ä–∏–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã
    if (messages.length === 0) {
      const roomExists = await Room.findById(roomId);
      if (!roomExists) {
        return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
      }
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–≤—Ç–æ—Ä–µ
    const messagesWithAuthors = await Promise.all(
      messages.map(async msg => {
        const user = await User.findById(msg.sender_id);
        return {
          ...msg,
          user_name: user?.name || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π'
        };
      })
    );

    res.json(messages);
  } catch (error) {
    console.error('[ERROR] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π' });
  }
};


===== server/controllers/message.controller.js =====
// server/controllers/message.controller.js
const Message = require('../models/message.model');

exports.updateMessage = async (req, res) => {
  try {
    const { messageId } = req.params;
    const { text } = req.body;
    // –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞ –≤–Ω—É—Ç—Ä–∏ –º–æ–¥–µ–ª–∏
    const updated = await Message.updateText(messageId, req.userId, text);
    if (!updated) return res.status(403).json({ error: '–ù–µ–ª—å–∑—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —á—É–∂–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ' });
    global._io.emit('message-updated', { messageId, text });
    res.json({ messageId, text });
  } catch (e) {
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è' });
  }
};

exports.deleteMessage = async (req, res) => {
  try {
    const { messageId } = req.params;
    const deleted = await Message.delete(messageId, req.userId);
    if (!deleted) return res.status(403).json({ error: '–ù–µ–ª—å–∑—è —É–¥–∞–ª—è—Ç—å —á—É–∂–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ' });
    global._io.emit('message-deleted', { messageId });
    res.json({ success: true });
  } catch (e) {
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è' });
  }
};


===== server/controllers/room.controller.js =====
const Room = require("../models/room.model");

exports.getAllRooms = async (req, res) => {
  try {
    const rooms = await Room.getAll();
    res.json(rooms);
  } catch (error) {
    res.status(500).json({ error: "Failed to fetch rooms" });
  }
};

exports.createRoom = async (req, res) => {
  try {
    const { name } = req.body;
    const room = await Room.create(name, req.userId);
    // –≠–º–∏—Ç–∏–º —Å–æ–±—ã—Ç–∏–µ –≤—Å–µ–º –∫–ª–∏–µ–Ω—Ç–∞–º
    global._io.emit('room-created', room);
    res.status(201).json(room);
  } catch (error) {
    res.status(500).json({ error: "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã" });
  }
};

exports.getRoom = async (req, res) => {
  try {
    const { roomId } = req.params;
    const room = await Room.findById(roomId);
    if (!room) {
      return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
    }
    res.json(room);
  } catch (error) {
    res.status(500).json({ error: "–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã" });
  }
};

exports.deleteRoom = async (req, res) => {
  try {
    const { roomId } = req.params;
    const isOwner = await Room.isOwner(roomId, req.userId);
    if (!isOwner) return res.status(403).json({ error: "–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å –º–æ–∂–µ—Ç —É–¥–∞–ª–∏—Ç—å –∫–æ–º–Ω–∞—Ç—É" });
    const success = await Room.delete(roomId);
    if (!success) return res.status(404).json({ error: "–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
    // –≠–º–∏—Ç–∏–º —Å–æ–±—ã—Ç–∏–µ —É–¥–∞–ª–µ–Ω–∏—è
    global._io.emit('room-deleted', { roomId: Number(roomId) });
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: "–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–æ–º–Ω–∞—Ç—ã" });
  }
};


===== server/controllers/task.controller.js =====
const Task = require('../models/task.model');

exports.createTask = async (req, res) => {
  try {
    const { title, description, deadline } = req.body;
    const task = await Task.create(title, description, req.userId, deadline);
    res.status(201).json(task);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create task' });
  }
};

exports.getTasks = async (req, res) => {
  try {
    const tasks = await Task.findAllByUser(req.userId);
    res.json(tasks);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch tasks' });
  }
};

exports.updateTask = async (req, res) => {
  try {
    const { taskId } = req.params;
    const { status } = req.body;
    const task = await Task.updateStatus(taskId, status);
    res.json(task);
  } catch (error) {
    res.status(500).json({ error: 'Failed to update task' });
  }
};


===== server/index.js =====
const express = require('express');
const http = require('http');
const fs = require('fs');
const pool = require('./config/db');
const socketAuth = require('./middleware/socketAuth');
const Message = require('./models/message.model');
const User = require('./models/user.model');
const path = require('path');
const chatController = require('./controllers/chat.controller');
const callService = require('./services/call.service');
const messageRoutes = require('./routes/message.routes');

pool.query('SELECT NOW()', (err) => {
  if (err) console.error('PostgreSQL connection error:', err);
  else console.log('PostgreSQL connected successfully');
});

const authRoutes = require('./routes/auth.routes');
const app = express();

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use('/api/messages', messageRoutes);

// CORS
const cors = require('cors');
app.use(cors({
  origin: [
    'http://localhost:3001',
    'http://192.168.0.104:3001'
  ],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));

app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// Routes
app.use('/api/auth', require('./routes/auth.routes'));
app.use('/api/tasks', require('./routes/task.routes'));
app.use('/api/chat', require('./routes/chat.routes'));
app.use('/api/rooms', require('./routes/room.routes'));
app.use('/api/calls', require('./routes/call.routes'));

app.get('/api/profile', require('./middleware/auth'), (req, res) => {
  res.json({ userId: req.userId });
});
app.get('/api/calls/active', (req, res) => {
  res.json(Array.from(callService.activeCalls.entries()));
});

// uncaught exceptions
process.on('uncaughtException', error => {
  console.error(`[CRASH] –ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: ${error.message}`);
  process.exit(1);
});

const server = http.createServer(app);
const io = require('socket.io')(server, {
  cors: {
    origin: [
      'http://localhost:3001',
      'http://192.168.0.104:3001'
    ],
    methods: ['GET', 'POST'],
    allowedHeaders: ['Authorization'],
    credentials: true
  },
  transports: ['websocket', 'polling']
});
io.use(socketAuth);
global._io = io;
chatController.setIO(io);

// Track active connections for conference
const activeConnections = new Map(); // roomId -> Set(socket.id)

io.on('connection', socket => {
  console.log('New socket:', socket.id, 'userId:', socket.userId);

  // Chat room join
  socket.on('joinRoom', roomId => socket.join(roomId));

  socket.on('sendMessage', async (data) => {
    try {
      const { text, roomId } = data;
      if (!text?.trim()) return;

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
      const message = await Message.create(text, socket.userId, roomId);
      // –ë–µ—Ä—ë–º –∏–º—è –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
      const user = await User.findById(socket.userId);

      // –°–æ–±–∏—Ä–∞–µ–º –ø–æ–ª–µ–∑–Ω—É—é –Ω–∞–≥—Ä—É–∑–∫—É
      const payload = {
        ...message,
        sender_name: user.name
      };

      // –≠–º–∏—Ç–∏–º –≤—Å–µ–º –≤ –∫–æ–º–Ω–∞—Ç–µ
      io.to(roomId).emit('newMessage', payload);
      console.log('üì® sendMessage:', payload);
    } catch (err) {
      console.error('–û—à–∏–±–∫–∞ –≤ sendMessage:', err);
    }
  });

  // 1:1 call and chat logic omitted‚Ä¶

  // Conference events
  socket.on('create-conference', roomId => {
    socket.join(roomId);
    activeConnections.set(roomId, new Set([socket.id]));
    socket.to(roomId).emit('conference-started', { roomId });
  });

  socket.on('join-conference', ({ roomId, userId, username }) => {
    socket.join(roomId);
    // add to active set
    const set = activeConnections.get(roomId) || new Set();
    set.add(socket.id);
    activeConnections.set(roomId, set);
    socket.to(roomId).emit('new-conference-participant', { peerId: socket.id, initiatorId: userId });
  });

  socket.on('leave-conference', ({ roomId }) => {
    socket.leave(roomId);
    const set = activeConnections.get(roomId);
    if (set) {
      set.delete(socket.id);
      if (set.size === 0) activeConnections.delete(roomId);
      else activeConnections.set(roomId, set);
    }
    socket.to(roomId).emit('conference-participant-left', { peerId: socket.id });
  });

  // Screen share handlers at top-level
  socket.on('screen-share', ({ roomId, peerId }) => {
    console.log(`‚öôÔ∏è  –°–µ—Ä–≤–µ—Ä –ø–æ–ª—É—á–∏–ª screen-share –æ—Ç ${peerId} –≤ –∫–æ–º–Ω–∞—Ç–µ ${roomId}`);
    socket.to(roomId).emit('screen-share', { peerId });
  });
  socket.on('screen-share-stop', ({ roomId, peerId }) => {
    console.log(`‚öôÔ∏è  –°–µ—Ä–≤–µ—Ä –ø–æ–ª—É—á–∏–ª screen-share-stop –æ—Ç ${peerId} –≤ –∫–æ–º–Ω–∞—Ç–µ ${roomId}`);
    socket.to(roomId).emit('screen-share-stop', { peerId });
  });
  socket.on('screen-share-join', ({ roomId, targetPeerId }) => {
    console.log(`‚öôÔ∏è  –°–µ—Ä–≤–µ—Ä –ø–æ–ª—É—á–∏–ª screen-share-join –æ—Ç ${socket.id}, —à–ª—ë—Ç screen-share-joined -> ${targetPeerId}`);
    io.to(targetPeerId).emit('screen-share-joined', { requesterId: socket.id });
  });

  // WebRTC signaling
  socket.on('webrtc-signal', ({ target, senderId, signal, roomId }) => {
    io.to(target).emit('webrtc-signal', { senderId, signal, roomId });
  });

  // Disconnect
  socket.on('disconnect', () => {
    // clean up conference
    for (const [roomId, set] of activeConnections) {
      if (set.has(socket.id)) {
        set.delete(socket.id);
        socket.to(roomId).emit('conference-participant-left', { peerId: socket.id });
        if (set.size === 0) activeConnections.delete(roomId);
      }
    }
  });
});

const PORT = 3000;
// –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ 0.0.0.0, —á—Ç–æ–±—ã —Å–ª—É—à–∞—Ç—å –Ω–∞ –≤—Å–µ—Ö –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞—Ö
server.listen(PORT, '0.0.0.0', () => {
  console.log(`Server listening on 0.0.0.0:${PORT}`);
});

// ensure uploads dir
fs.mkdirSync(path.join(__dirname, 'uploads'), { recursive: true });


===== server/middleware/auth.js =====
const jwt = require('jsonwebtoken');
const User = require('../models/user.model');

module.exports = async (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');

  if (!token) return res.status(401).json({ error: 'Access denied' });

  try {
    const decoded = jwt.verify(token, 'your_jwt_secret');
    const user = await User.findById(decoded.userId);
    req.user = user;
    req.userId = decoded.userId; // –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    next();

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
  } catch (error) {
    res.status(400).json({ error: 'Invalid token' });
  }
};


===== server/middleware/logger.js =====
module.exports = (req, res, next) => {
  const start = Date.now();

  // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ö–æ–¥—è—â–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
  console.log(`[REQUEST] ${req.method} ${req.url}`);

  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`[RESPONSE] ${req.method} ${req.url} - Status: ${res.statusCode} (${duration}ms)`);
  });

  next();
};


===== server/middleware/socketAuth.js =====
const jwt = require('jsonwebtoken');

const socketAuth = (socket, next) => {
  try {
    const token = socket.handshake.auth.token;
    if (!token) {
      return next(new Error('Access denied: No token provided'));
    }

    const decoded = jwt.verify(token, 'your_jwt_secret');
    socket.userId = decoded.userId; // —Å–æ—Ö—Ä–∞–Ω—è–µ–º userId –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    next();
  } catch (error) {
    next(new Error('Invalid token'));
  }
};

module.exports = socketAuth;


===== server/middleware/upload.js =====
const multer = require("multer");
const path = require("path");
const fs = require("fs");

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –ø–∞–ø–∫–∏
const voiceDir = path.join(__dirname, "../uploads/voice");
fs.mkdirSync(voiceDir, { recursive: true });

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, voiceDir); // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const cleanName = file.originalname.replace(/[^a-zA-Z0-9\.]/g, '_');
    cb(null, uniqueSuffix + '-' + cleanName);
  }
});

const upload = multer({
  storage: storage,
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('audio/')) {
      cb(null, true);
    } else {
      cb(new Error('–¢–æ–ª—å–∫–æ –∞—É–¥–∏–æ—Ñ–∞–π–ª—ã —Ä–∞–∑—Ä–µ—à–µ–Ω—ã'));
    }
  }
});

module.exports = upload;


===== server/models/message.model.js =====
const pool = require('../config/db');

class Message {
  static async create(text, senderId, roomId, isVoiceMessage = false, fileUrl = null) {
    try {
      if (isVoiceMessage) text = "";
      const { rows } = await pool.query(
        `INSERT INTO messages (text, sender_id, room_id, is_voice_message, file_url)
       VALUES ($1, $2, $3, $4, $5) RETURNING *`,
        [text, senderId, roomId, isVoiceMessage, fileUrl]
      );
      console.log('[DB] –°–æ–æ–±—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ:', rows[0]); // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
      return rows[0];
    } catch (error) {
      console.error('[DB] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:', error);
      throw error;
    }
  }

  static async findByRoom(roomId) {
    const { rows } = await pool.query(
      `SELECT 
      m.id,
      m.text,
      m.sender_id,
      m.room_id,
      m.is_voice_message,
      m.file_url,
      m.created_at,
      u.name as user_name
    FROM messages m
    LEFT JOIN users u ON m.sender_id = u.id
    WHERE m.room_id = $1
    ORDER BY m.created_at ASC`,
      [roomId]
    );
    return rows;
  }

  static async delete(messageId) {
    const { rowCount } = await pool.query(
      "DELETE FROM messages WHERE id = $1",
      [messageId]
    );
    return rowCount > 0;
  }

  static async findById(messageId) {
    const { rows } = await pool.query(
      "SELECT * FROM messages WHERE id = $1",
      [messageId]
    );
    return rows[0];
  }

}

module.exports = Message;


===== server/models/room.model.js =====
const pool = require("../config/db");

class Room {
  static async create(name, creatorId) {
    const { rows } = await pool.query(
      "INSERT INTO rooms (name, creator_id) VALUES ($1, $2) RETURNING *",
      [name, creatorId]
    );
    return rows[0];
  }

  static async getAll() {
    const { rows } = await pool.query("SELECT * FROM rooms ORDER BY id ASC");
    return rows;
  }

  static async findById(roomId) {
    const { rows } = await pool.query("SELECT * FROM rooms WHERE id = $1", [roomId]);
    return rows[0];
  }

  static async delete(roomId) {
    const { rowCount } = await pool.query(
      "DELETE FROM rooms WHERE id = $1 RETURNING *",
      [roomId]
    );
    return rowCount > 0;
  }

  static async isOwner(roomId, userId) {
    const { rows } = await pool.query(
      "SELECT creator_id FROM rooms WHERE id = $1",
      [roomId]
    );
    return rows[0]?.creator_id === userId;
  }
}

module.exports = Room;


===== server/models/task.model.js =====
const pool = require('../config/db');
class Task {
  static async create(title, description, assigneeId, deadline) {
    const { rows } = await pool.query(
      `INSERT INTO tasks (title, description, status, assignee_id, deadline)
       VALUES ($1, $2, 'todo', $3, $4) RETURNING *`,
      [title, description, assigneeId, deadline]
    );
    return rows[0];
  }

  static async findAllByUser(userId) {
    const { rows } = await pool.query(
      `SELECT * FROM tasks WHERE assignee_id = $1`,
      [userId]
    );
    return rows;
  }

  static async updateStatus(taskId, newStatus) {
    const { rows } = await pool.query(
      `UPDATE tasks SET status = $1 WHERE id = $2 RETURNING *`,
      [newStatus, taskId]
    );
    return rows[0];
  }
}

module.exports = Task;


===== server/models/user.model.js =====
const pool = require('../config/db');
class User {
  static async findByEmail(email) {
    try {
      console.log(`[DB] –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email: ${email}`);
      const { rows } = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
      return rows[0];
    } catch (error) {
      console.error(`[DB] –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${error.message}`);
      throw error;
    }
  }

  static async findById(id) {
    try {
      const { rows } = await pool.query('SELECT * FROM users WHERE id = $1', [id]);
      return rows[0];
    } catch (error) {
      console.error(`[DB] –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${error.message}`);
      throw error;
    }
  }

  static async createUser(name, email, passwordHash) {
    const { rows } = await pool.query(
      'INSERT INTO users (name, email, password_hash) VALUES ($1, $2, $3) RETURNING *',
      [name, email, passwordHash]
    );
    return rows[0];
  }
}
module.exports = User;


===== server/node =====


===== server/package.json =====
{
  "name": "zvonok",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "buffer": "^6.0.3",
    "cors": "^2.8.5",
    "crypto-browserify": "^3.12.1",
    "express": "^5.1.0",
    "express-router": "^0.0.1",
    "jsonwebtoken": "^9.0.2",
    "mediasoup": "^3.15.7",
    "multer": "^1.4.5-lts.2",
    "path-to-regexp": "^8.2.0",
    "pg": "^8.15.6",
    "process": "^0.11.10",
    "simple-peer": "^9.11.1",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "stream-browserify": "^3.0.0",
    "window": "^4.2.7"
  }
}


===== server/routes/auth.routes.js =====
const express = require('express');
const router = express.Router();
const authController = require('../controllers/auth.controller');
const authMiddleware = require('../middleware/auth');

router.get('/profile', authMiddleware, async (req, res) => {
    try {
        // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ë–î
        const user = await User.findById(req.user.id);
        if (!user) {
            return res.status(404).json({ error: "User not found" });
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        res.json({
            user: {
                id: user.id,
                name: user.name,
                email: user.email
            }
        });

    } catch (error) {
        res.status(500).json({ error: "Server error" });
    }
});

router.post('/register', authController.register);
router.post('/login', authController.login);

module.exports = router;


===== server/routes/call.routes.js =====
const express = require('express');
const router = express.Router();
const authMiddleware = require('../middleware/auth');
const activeCalls = require('../services/call.service');

router.post('/initiate', authMiddleware, (req, res) => {
  const { targetUserId, roomId } = req.body;
  const callId = activeCalls.initiateCall(req.userId, targetUserId, roomId);
  res.json({ callId });
});

router.post('/accept', authMiddleware, (req, res) => {
  const { callId } = req.body;
  const success = activeCalls.acceptCall(callId, req.userId);
  res.json({ success });
});

module.exports = router;


===== server/routes/chat.routes.js =====
const express = require('express');
const router = express.Router();
const chatController = require('../controllers/chat.controller');
const authMiddleware = require('../middleware/auth');
const upload = require("../middleware/upload");

router.post('/messages', authMiddleware, chatController.sendMessage);
router.get('/rooms/:roomId/messages', authMiddleware, chatController.getMessages);
router.delete('/messages/:messageId', authMiddleware, chatController.deleteMessage);
router.post('/voice', authMiddleware,
    upload.single('voice'),
    (req, res, next) => {
        console.log("Middleware: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏");
        next();
    },
    (req, res, next) => {
        console.log("–§–∞–π–ª:", req.file); // –î–æ–±–∞–≤—å—Ç–µ –ª–æ–≥ —Ñ–∞–π–ª–∞
        req.body.roomId = req.body.roomId;
        next();
    },
    chatController.sendVoiceMessage
);

module.exports = router;


===== server/routes/message.routes.js =====
const express = require('express');
const router = express.Router();
const { updateMessage, deleteMessage } = require('../controllers/message.controller');
const auth = require('../middleware/auth');

router.put('/:messageId', auth, updateMessage);
router.delete('/:messageId', auth, deleteMessage);

module.exports = router;


===== server/routes/room.routes.js =====
const express = require("express");
const router = express.Router();
const roomController = require("../controllers/room.controller");
const authMiddleware = require("../middleware/auth");

router.post("/", authMiddleware, roomController.createRoom);
router.get("/:roomId", authMiddleware, roomController.getRoom);
router.get("/", authMiddleware, roomController.getAllRooms);
router.delete("/:roomId", authMiddleware, roomController.deleteRoom);

module.exports = router;


===== server/routes/task.routes.js =====
const express = require('express');
const router = express.Router();
const taskController = require('../controllers/task.controller');
const authMiddleware = require('../middleware/auth');

router.post('/', authMiddleware, taskController.createTask);
router.get('/', authMiddleware, taskController.getTasks);
router.patch('/:taskId', authMiddleware, taskController.updateTask);

module.exports = router;


===== server/services/call.service.js =====
class CallService {
  constructor() {
    this.activeCalls = new Map(); // callId -> { initiatorId, targetId, roomId, status }
    this.conferenceRooms = new Map(); // roomId ‚Üí Set<userId>
  }

  // –ú–µ—Ç–æ–¥—ã –¥–ª—è 1:1 –∑–≤–æ–Ω–∫–æ–≤
  initiateCall(initiatorId, targetId, roomId) {
    const callId = `call_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
    this.activeCalls.set(callId, {
      initiatorId,
      targetId,
      roomId,
      status: 'ringing'
    });
    return callId;
  }

  acceptCall(callId, userId) {
    const call = this.activeCalls.get(callId);
    if (call && call.targetId === userId) {
      call.status = 'active';
      return true;
    }
    return false;
  }

  // –ú–µ—Ç–æ–¥—ã –¥–ª—è –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–π
  joinConference(roomId, userId) {
    if (!this.conferenceRooms.has(roomId)) {
      this.conferenceRooms.set(roomId, new Set());
    }
    this.conferenceRooms.get(roomId).add(userId);
  }

  leaveConference(roomId, userId) {
    if (this.conferenceRooms.has(roomId)) {
      this.conferenceRooms.get(roomId).delete(userId);
      if (this.conferenceRooms.get(roomId).size === 0) {
        this.conferenceRooms.delete(roomId);
      }
    }
  }

  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏
  getConferenceParticipants(roomId) {
    const participants = this.conferenceRooms.get(roomId);
    return participants ? Array.from(participants) : [];
  }
}

module.exports = new CallService();


===== server/services/webrtc.service.js =====
class WebRTCService {
  constructor() {
    this.iceServers = [
      { urls: 'stun:stun.l.google.com:19302' },
      { 
        urls: 'turn:your-turn-server.com',
        username: 'user',
        credential: 'password'
      }
    ];
  }

  getICEServers() {
    return this.iceServers;
  }

  generateRoomId() {
    return Math.random().toString(36).substr(2, 9);
  }
}

module.exports = new WebRTCService();


===== server/sql/sql.sql =====
-- –°–æ–∑–¥–∞–µ–º —Ç–∏–ø –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–¥–∞—á–∏ (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ ENUM)
CREATE TYPE task_status AS ENUM ('todo', 'in_progress', 'done');

-- –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    --org_id INTEGER,  -- –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–∞–±–ª–∏—Ü–∞ organizations, –¥–æ–±–∞–≤—å—Ç–µ FOREIGN KEY
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –∫–æ–º–Ω–∞—Ç (—á–∞—Ç—ã/–∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏–∏)
CREATE TABLE rooms (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255),
    type VARCHAR(20) CHECK (type IN ('chat', 'conference')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
CREATE TABLE messages (
    id SERIAL PRIMARY KEY,
    text TEXT,
    sender_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    room_id INTEGER REFERENCES rooms(id) ON DELETE CASCADE,
    is_voice_message BOOLEAN DEFAULT FALSE,
    file_url VARCHAR(512),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –∑–∞–¥–∞—á (–≤–∞—Ä–∏–∞–Ω—Ç —Å ENUM)
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    status task_status DEFAULT 'todo',
    assignee_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
    deadline TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞
CREATE INDEX idx_messages_room ON messages(room_id);
CREATE INDEX idx_tasks_assignee ON tasks(assignee_id);


